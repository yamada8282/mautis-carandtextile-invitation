<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>第一回 繊維産業研究報告会 -車と繊維-</title>
    <meta name="description" content="繊維産業研究会による初の研究成果発表会。自動車用繊維素材を用いた作品展示とファッションショーのご案内。">
    <!-- Google Fonts: Noto Sans JP and Barlow (as alternative to DIN) -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Barlow:wght@400;700&family=Noto+Sans+JP:wght@400;700&display=swap"
        rel="stylesheet">
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            overflow: hidden;
            overflow-x: hidden;
            background-color: #fff;
            /* 背景を白に */
            font-family: 'DIN 2014', 'Barlow', 'Noto Sans JP', sans-serif;
            width: 100%;
            -webkit-overflow-scrolling: touch;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100vh;
        }

        /* CRTモニター風の走査線（少し薄くしました） */
        #scanlines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.04) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.02), rgba(0, 255, 0, 0.01), rgba(0, 0, 255, 0.02));
            background-size: 100% 4px, 6px 100%;
            pointer-events: none;
            z-index: 10;
        }

        #ui-layer {
            position: absolute;
            /* 字幕の位置 */
            top: 30%;
            width: 100%;
            text-align: center;
            color: #000;
            font-size: 13px;
            pointer-events: none;
            z-index: 20;
            font-family: 'DIN 2014', 'Barlow', 'Noto Sans JP', sans-serif;
            line-height: 1.5;
        }

        /* 速度計 */
        #speedometer {
            position: fixed;
            top: 20px;
            /* right: 20px; */
            /* 中央配置に変更 */
            left: 50%;
            transform: translateX(-50%);
            color: #000;
            font-family: 'DIN 2014', 'Barlow', 'Noto Sans JP', sans-serif;
            font-size: 18px;
            pointer-events: none;
            z-index: 30;
            padding: 10px 15px;
            border-bottom: 2px solid #000;
            text-align: center;
        }

        #speedometer .label {
            font-size: 10px;
            color: #000;
            margin-bottom: 5px;
        }

        #speedometer .speed {
            font-size: 24px;
            line-height: 1;
        }

        #speedometer .unit {
            font-size: 11px;
            color: #000;
            margin-left: 5px;
        }

        /* スタート画面 */
        #start-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            height: 100dvh;
            min-height: 100vh;
            min-height: 100dvh;
            background: #fff;
            z-index: 200;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #000;
            font-family: 'DIN 2014', 'Barlow', 'Noto Sans JP', sans-serif;
            letter-spacing: 0.1em;
            overflow: hidden;
            padding: 20px 0;
        }

        #start-screen.hidden {
            display: none;
        }

        #start-screen .event-title {
            font-size: 22px;
            margin-bottom: 5px;
            text-align: center;
            color: #000;
            text-transform: uppercase;
        }

        #start-screen .event-date {
            font-size: 12px;
            margin-bottom: 60px;
            color: #000;
            border-top: 1px solid #000;
            padding-top: 5px;
            display: inline-block;
        }

        #start-screen .init-button {
            padding: 15px 50px;
            background: #fff;
            border: 1px solid #000;
            color: #000;
            border: 1px solid #000;
            color: #000;
            font-family: 'DIN 2014', 'Barlow', 'Noto Sans JP', sans-serif;
            font-size: 14px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 0.2em;
            position: relative;
            overflow: hidden;
            transition: all 0.1s;
        }

        #start-screen .init-button:hover {
            background: #000;
            color: #fff;
        }

        #start-screen .init-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.2);
            transform: skewX(-20deg);
            animation: shine 3s infinite;
        }

        @keyframes shine {
            0% {
                left: -100%;
            }

            20% {
                left: 200%;
            }

            100% {
                left: 200%;
            }
        }

        #start-screen .glitch-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            opacity: 0;
            pointer-events: none;
            z-index: 10;
        }

        #start-screen .glitch-overlay.active {
            animation: glitch 0.5s;
        }

        @keyframes glitch {
            0% {
                transform: translate(0);
            }

            20% {
                transform: translate(-5px, 5px);
            }

            40% {
                transform: translate(-5px, -5px);
            }

            60% {
                transform: translate(5px, 5px);
            }

            80% {
                transform: translate(5px, -5px);
            }

            100% {
                transform: translate(0);
            }
        }

        /* ホワイトアウト・オーバーレイ */
        #whiteout-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #fff;
            opacity: 0;
            pointer-events: none;
            z-index: 5000;
        }

        /* 起動時ローディングオーバーレイ */
        #loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #fff;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            transition: opacity 0.5s;
        }

        #loading-bar-container {
            width: 200px;
            height: 2px;
            background: #eee;
            margin-top: 20px;
            position: relative;
        }

        #loading-progress {
            width: 0%;
            height: 100%;
            background: #000;
            transition: width 0.3s;
        }

        #loading-overlay-text {
            font-family: 'DIN 2014', sans-serif;
            font-size: 10px;
            letter-spacing: 0.2em;
            color: #888;
            margin-top: 15px;
        }

        /* 結果画面 */
        #result-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            height: 100dvh;
            min-height: 100vh;
            min-height: 100dvh;
            background: #fff;
            z-index: 100;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            color: #000;
            font-family: 'DIN 2014', 'Barlow', 'Noto Sans JP', sans-serif;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            padding: 60px 20px;
            box-sizing: border-box;
        }

        #result-screen.active {
            display: flex;
        }

        #result-screen .loading {
            font-size: 24px;
            margin-bottom: 20px;
        }

        #result-screen .header {
            font-size: 20px;
            margin-bottom: 30px;
            color: #000;
            text-align: center;
            border-bottom: 2px solid #000;
            padding-bottom: 10px;
            width: 90%;
        }

        #result-screen .loading {
            font-size: 24px;
            margin-bottom: 20px;
        }

        #result-screen .material-image {
            max-width: 90%;
            max-height: 50vh;
            border: 1px solid #000;
            margin: 20px 0;
            background: #fff;
        }

        #result-screen .material-id {
            font-size: 18px;
            margin: 15px 0;
            text-align: center;
            color: #000;
        }

        #result-screen .spec-info {
            font-size: 14px;
            margin: 10px 0;
            text-align: center;
            color: #666;
        }

        #result-screen .share-buttons {
            display: flex;
            gap: 15px;
            margin-top: 20px;
        }

        #result-screen .share-btn {
            padding: 10px 20px;
            background: #fff;
            border: 1px solid #000;
            color: #000;
            cursor: pointer;
            font-family: 'DIN 2014', 'Barlow', 'Noto Sans JP', sans-serif;
            font-size: 14px;
            transition: all 0.3s;
        }

        #result-screen .share-btn:hover {
            background: #000;
            color: #fff;
        }

        #result-screen .reserve-btn,
        #result-screen .calendar-btn {
            display: block;
            width: 80%;
            max-width: 300px;
            padding: 15px 30px;
            font-family: 'DIN 2014', 'Barlow', 'Noto Sans JP', sans-serif;
            font-size: 16px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            cursor: pointer;
            transition: all 0.3s;
            margin: 0 auto;
            border-radius: 4px;
            text-align: center;
        }

        #result-screen .reserve-btn {
            background: #000;
            border: none;
            color: #fff;
            margin-top: 20px;
        }

        #result-screen .calendar-btn {
            background: #fff;
            border: 1px solid #000;
            color: #000;
            margin-top: 10px;
        }

        #result-screen .reserve-btn:hover {
            opacity: 0.8;
            transform: translateY(-2px);
        }

        #result-screen .calendar-btn:hover {
            background: #f8f8f8;
            transform: translateY(-2px);
        }

        #result-screen {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #fff;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            z-index: 100;
            overflow-y: auto;
            overflow-x: hidden;
            /* 横揺れを防止 */
            padding-bottom: 50px;
            -webkit-overflow-scrolling: touch;
        }

        #result-screen.active {
            display: flex;
        }

        /* 統合レポートスタイル */
        #analysis-report {
            width: 85%;
            max-width: 500px;
            margin: 20px auto;
            text-align: left;
            font-family: 'Noto Sans JP', sans-serif;
            color: #333;
            line-height: 1.8;
            font-size: 13px;
        }

        .report-section {
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 1px solid #eee;
        }

        .report-title {
            font-family: 'DIN 2014', sans-serif;
            font-size: 11px;
            letter-spacing: 2px;
            color: #999;
            margin-bottom: 15px;
            text-transform: uppercase;
        }

        .report-text {
            margin-bottom: 15px;
        }

        .diagnosis-name-en {
            font-family: 'DIN 2014', sans-serif;
            font-size: 24px;
            font-weight: 700;
            letter-spacing: 1px;
            margin-top: 20px;
            line-height: 1.1;
        }

        .diagnosis-name-jp {
            font-size: 14px;
            font-weight: 500;
            margin-top: 5px;
            opacity: 0.8;
            margin-bottom: 15px;
        }

        .diagnosis-desc {
            font-size: 12px;
            opacity: 0.7;
            font-style: italic;
        }

        /* 画像表示調整 */
        .material-image {
            width: 250px;
            height: 250px;
            object-fit: cover;
            border-radius: 50%;
            /* 丸くする */
            margin: 30px 0 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }

        .material-id {
            font-family: 'DIN 2014', monospace;
            font-size: 12px;
            letter-spacing: 2px;
            color: #ccc;
            margin-bottom: 10px;
        }

        /* オーディオコントロール */
        #start-audio-indicator {
            font-size: 10px;
            color: #000;
            /* Fixed: White on White was invisible */
            margin-top: 15px;
            opacity: 0.6;
            letter-spacing: 1px;
            cursor: default;
            transition: opacity 0.3s;
            font-family: 'DIN 2014', sans-serif;
        }

        #start-audio-indicator:hover {
            opacity: 1;
        }

        #audio-controls {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 2000;
            cursor: pointer;
            display: none;
            pointer-events: auto;
            /* Fixed: Parent #ui-layer has pointer-events: none */
        }

        .audio-btn {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: #fff;
            padding: 6px 10px;
            font-family: 'DIN 2014', sans-serif;
            font-size: 10px;
            border-radius: 4px;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .audio-btn:hover {
            background: #fff;
            color: #000;
        }

        /* SKIPボタン */
        #skip-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: #fff;
            padding: 6px 12px;
            font-family: 'DIN 2014', sans-serif;
            font-size: 11px;
            border-radius: 4px;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            z-index: 2000;
            display: none;
            /* 初期は非表示 */
            pointer-events: auto;
        }

        #skip-btn:hover {
            background: #fff;
            color: #000;
        }

        /* TAP TO START */
        #tap-to-start {
            position: fixed;
            top: 35%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'DIN 2014', sans-serif;
            font-size: 24px;
            letter-spacing: 4px;
            color: #333;
            animation: blink 1.5s infinite;
            display: none;
            z-index: 2000;
            pointer-events: none;
        }

        @keyframes blink {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.3;
            }
        }

        /* スピードメーター位置調整（不要になったが念のため残すか、削除） */
        /* #speedometer.center-top { ... } 削除済み */

        /* 字幕スタイル（念のため定義） */
        #caption {
            position: fixed;
            top: 30%;
            /* 画面上部へ移動 */
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            text-align: center;
            color: #000;
            /* 黒文字に変更 */
            font-family: 'DIN 2014', 'Noto Sans JP', sans-serif;
            font-size: 14px;
            pointer-events: none;
            z-index: 1500;
            transition: opacity 0.5s;
        }
    </style>
</head>

<body>

    <!-- デバイス制限画面 -->
    <div id="device-block"
        style="display: none; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; height: 100dvh; background: #fff; z-index: 99999; flex-direction: column; justify-content: center; align-items: center; text-align: center; padding: 40px 30px;">
        <div
            style="width: 40px; height: 68px; border: 2px solid #000; border-radius: 8px; margin-bottom: 30px; position: relative;">
            <div
                style="width: 16px; height: 2px; background: #000; position: absolute; top: 6px; left: 50%; transform: translateX(-50%);">
            </div>
            <div
                style="width: 8px; height: 8px; border: 1.5px solid #000; border-radius: 50%; position: absolute; bottom: 5px; left: 50%; transform: translateX(-50%);">
            </div>
        </div>
        <div
            style="font-family: 'DIN 2014', 'Barlow', sans-serif; font-size: 11px; letter-spacing: 0.3em; text-transform: uppercase; color: #000; margin-bottom: 25px;">
            Mobile Portrait Only</div>
        <div style="width: 40px; height: 1px; background: #000; margin-bottom: 25px;"></div>
        <div
            style="font-family: 'Noto Sans JP', sans-serif; font-size: 12px; color: #333; line-height: 1.8; margin-bottom: 15px;">
            このコンテンツはスマートフォンの<br>縦画面専用です。
        </div>
        <div
            style="font-family: 'DIN 2014', 'Barlow', sans-serif; font-size: 10px; color: #999; line-height: 1.8; letter-spacing: 0.05em;">
            This content is optimized for<br>mobile devices in portrait mode.
        </div>
    </div>

    <!-- 横画面警告 -->
    <div id="rotate-block"
        style="display: none; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; height: 100dvh; background: #fff; z-index: 99998; flex-direction: column; justify-content: center; align-items: center; text-align: center; padding: 40px 30px;">
        <div
            style="width: 68px; height: 40px; border: 2px solid #000; border-radius: 8px; margin-bottom: 15px; position: relative;">
            <div
                style="width: 2px; height: 16px; background: #000; position: absolute; left: 6px; top: 50%; transform: translateY(-50%);">
            </div>
        </div>
        <div style="font-size: 20px; margin-bottom: 15px; animation: rotateHint 2s ease-in-out infinite;">↻</div>
        <div
            style="font-family: 'DIN 2014', 'Barlow', sans-serif; font-size: 11px; letter-spacing: 0.3em; text-transform: uppercase; color: #000; margin-bottom: 25px;">
            Rotate Your Device</div>
        <div style="width: 40px; height: 1px; background: #000; margin-bottom: 25px;"></div>
        <div
            style="font-family: 'Noto Sans JP', sans-serif; font-size: 12px; color: #333; line-height: 1.8; margin-bottom: 15px;">
            端末を縦向きに回転してください。
        </div>
        <div
            style="font-family: 'DIN 2014', 'Barlow', sans-serif; font-size: 10px; color: #999; line-height: 1.8; letter-spacing: 0.05em;">
            Please rotate your device<br>to portrait orientation.
        </div>
    </div>
    <style>
        @keyframes rotateHint {

            0%,
            100% {
                transform: rotate(0deg);
            }

            50% {
                transform: rotate(-90deg);
            }
        }
    </style>

    <!-- スタート画面 -->
    <div id="start-screen">
        <div class="glitch-overlay" id="glitch-overlay"></div>
        <div class="event-title">第一回 繊維産業研究報告会<br>-車と繊維-</div>
        <div class="event-date">2026.02.28 SAT</div>

        <!-- 緯糸モード説明 -->
        <div id="weft-mode-info"
            style="display: none; background: rgba(0,0,0,0.05); padding: 15px; margin: 15px 0; border-left: 3px solid #333; text-align: left; max-width: 280px;">
            <div style="font-size: 11px; font-weight: bold; margin-bottom: 8px;">あなたは「緯糸（よこいと）」です</div>
            <div style="font-size: 10px; color: #555; line-height: 1.5;">
                誰かが織った「経糸（たていと）」が待っています。<br>
                あなたの走りが「緯糸」となり、<br>
                2人の糸が交差して、1枚の布が完成します。
            </div>
        </div>

        <button class="init-button" id="init-button">START</button>
        <div id="start-hint" style="font-size: 10px; color: #666; margin-top: 10px;">タップしてゲームを始める</div>
        <div id="start-audio-indicator">( SOUND RECOMMENDED )</div>
    </div>

    <div id="scanlines"></div>
    <div id="whiteout-overlay"></div>

    <!-- 起動時ローディング -->
    <div id="loading-overlay">
        <div style="font-family: 'DIN 2014', sans-serif; font-size: 14px; letter-spacing: 0.3em; font-weight: bold;">
            INITIALIZING</div>
        <div id="loading-bar-container">
            <div id="loading-progress"></div>
        </div>
        <div id="loading-overlay-text">PRELOADING ASSETS...</div>
    </div>

    <div id="ui-layer">
        <p id="caption"></p>
        <div id="audio-controls">
            <div id="game-audio-btn" class="audio-btn" onclick="toggleAudio()">SOUND ON</div>
        </div>
        <div id="skip-btn">SKIP &gt;&gt;</div>
        <div id="tap-to-start">TAP TO START</div>
    </div>
    <div id="speedometer">
        <div class="label">SPEED</div>
        <div class="speed"><span id="speedValue">0</span><span class="unit">km/h</span></div>
    </div>
    <canvas id="gameCanvas"></canvas>

    <!-- 操作ヒント -->
    <div id="control-hint"
        style="display: none; position: fixed; bottom: 60%; left: 0; right: 0; pointer-events: none; z-index: 50;">
        <div style="display: flex; justify-content: center; align-items: center; gap: 80px; opacity: 0.7;">
            <div id="hint-left"
                style="font-size: 60px; font-weight: 100; color: #333; animation: hintPulse 1.5s ease-in-out infinite;">
                ‹
            </div>
            <div style="font-size: 11px; color: #666; text-align: center; letter-spacing: 2px;">
                DRAG or ← →
            </div>
            <div id="hint-right"
                style="font-size: 60px; font-weight: 100; color: #333; animation: hintPulse 1.5s ease-in-out infinite 0.3s;">
                ›
            </div>
        </div>
    </div>
    <style>
        @keyframes hintPulse {

            0%,
            100% {
                opacity: 0.3;
                transform: translateX(0);
            }

            50% {
                opacity: 0.8;
            }
        }

        #hint-left {
            animation: hintLeft 1.5s ease-in-out infinite;
        }

        #hint-right {
            animation: hintRight 1.5s ease-in-out infinite;
        }

        @keyframes hintLeft {

            0%,
            100% {
                opacity: 0.3;
                transform: translateX(0);
            }

            50% {
                opacity: 0.8;
                transform: translateX(-10px);
            }
        }

        @keyframes hintRight {

            0%,
            100% {
                opacity: 0.3;
                transform: translateX(0);
            }

            50% {
                opacity: 0.8;
                transform: translateX(10px);
            }
        }
    </style>


    <!-- 結果画面 -->
    <div id="result-screen">
        <!-- Retry Button (Top Right) -->
        <button onclick="resetUserData()"
            style="position: absolute; top: 20px; right: 20px; background: none; border: none; color: #999; font-family: 'DIN 2014', sans-serif; font-size: 10px; cursor: pointer; letter-spacing: 0.1em; z-index: 200; opacity: 0.7;">
            RETRY
        </button>
        <div class="header" style="margin-top: 30px;">DRIVING RESULT</div>
        <div style="font-size: 10px; color: #666; margin-bottom: 20px;">走行解析結果</div>

        <div class="loading" id="loading-text">ANALYZING MATERIAL DATA...</div>

        <!-- 画像 -->
        <img id="material-image" class="material-image" style="display: none;" />

        <!-- マテリアルID -->
        <div class="material-id" id="material-id" style="display: none;"></div>

        <!-- VIP用チケットホルダー情報 -->
        <div id="vip-ticket-holder" style="display: none; width: 100%; text-align: center; margin: 10px 0 25px 0;">
            <div style="font-size: 9px; color: #888; letter-spacing: 0.2em; margin-bottom: 4px;">TICKET HOLDER</div>
            <div id="vip-holder-name"
                style="font-size: 18px; font-weight: bold; color: #000; letter-spacing: 0.05em; border-top: 1px solid #eee; border-bottom: 1px solid #eee; padding: 10px 0; width: 80%; margin: 0 auto;">
            </div>
        </div>

        <!-- 統合レポートエリア -->
        <div id="analysis-report" style="display: none;"></div>



        <!-- 予約ボタン（またはチケット保存ボタン） -->
        <button class="reserve-btn" id="reserve-btn" style="display: none;" onclick="goToReservation()">RESERVE
            TICKET</button>
        <button class="calendar-btn" id="calendar-btn" style="display: none;" onclick="addToCalendar()">ADD TO
            CALENDAR</button>

        <!-- コラボレーション・招待エリア (統合版) -->
        <div id="collab-section"
            style="margin-top: 25px; padding: 25px; border-top: 1px solid #eee; display: none; width: 90%; max-width: 500px; text-align: center;">

            <!-- A. 経糸モード (一般客・完了時) -->
            <div id="warp-mode-actions" style="display: none;">
                <div
                    style="font-size: 13px; font-weight: bold; margin-bottom: 12px; color: #000; letter-spacing: 0.1em;">
                    COMPLETE THE TEXTILE
                </div>
                <div style="font-size: 11px; color: #555; line-height: 1.7; margin-bottom: 25px;">
                    この布はまだ未完成（経糸のみ）です。<br>
                    誰かにリンクを送って、「緯糸」を織ってもらいましょう。<br><br>
                    ペアでテキスタイルを完成させた方には、<br>
                    Webコンテンツ参加特典をプレゼントいたします。
                </div>

                <!-- Invite Share Buttons -->
                <div style="display: flex; flex-direction: column; gap: 10px; align-items: center;">
                    <button class="share-btn" onclick="shareInviteToTwitter()"
                        style="width: 100%; max-width: 300px; background: #000; color: #fff; border: none; padding: 12px;">
                        Invite a Partner (X)
                    </button>
                    <button class="share-btn" onclick="shareInviteToLINE()"
                        style="width: 100%; max-width: 300px; background: #06c755; color: #fff; border: none; padding: 12px;">
                        Invite a Partner (LINE)
                    </button>
                    <button onclick="copyInviteLink()"
                        style="background:none; border:none; text-decoration:underline; font-size:10px; color:#999; cursor:pointer; margin-top: 5px;">
                        Copy Invite Link
                    </button>
                    <input type="text" id="invite-link-input" readonly style="position:absolute; left:-9999px;">
                </div>
            </div>

            <!-- B. 緯糸モード (コラボ客・完了時) -->
            <div id="weft-mode-result" style="display: none;">
                <div
                    style="font-size: 13px; font-weight: bold; margin-bottom: 12px; color: #000; letter-spacing: 0.1em;">
                    TEXTILE COMPLETED
                </div>
                <div style="font-size: 11px; color: #333; line-height: 1.7; margin-bottom: 25px;">
                    二人の糸が交差し、世界に一つの布が完成しました。<br>
                    <span style="font-size:0.9em; color:#666;">経糸: HOST / 緯糸: YOU</span><br><br>
                    ページ上部のテキスタイル画像付近をスクリーンショットなどで保存し、当日受付にて提示してください。<br>
                    Webコンテンツ参加特典をプレゼントいたします。
                </div>

                <div style="display: flex; flex-direction: column; gap: 10px; align-items: center;">
                    <button class="share-btn" onclick="reportToHostLINE()"
                        style="width: 100%; max-width: 300px; background: #06c755; color: #fff; border: none; padding: 12px;">
                        Share with Partner (LINE)
                    </button>
                    <div style="font-size:9px; color:#999; margin-top: -5px;">
                        ※保存した画像をLINEで送ってください
                    </div>
                    <button class="share-btn" onclick="shareToTwitter()"
                        style="width: 100%; max-width: 300px; background: #fff; color: #333; border: 1px solid #ddd; padding: 12px;">
                        Share on X
                    </button>
                </div>
            </div>

            <!-- C. VIPモード -->
            <div id="vip-mode-result" style="display: none;">
                <div
                    style="font-size: 13px; font-weight: bold; margin-bottom: 12px; color: #000; letter-spacing: 0.1em;">
                    YOUR TICKET IS READY
                </div>
                <div style="font-size: 11px; color: #333; line-height: 1.7; margin-bottom: 25px;">
                    あなただけのテキスタイルが完成しました。<br>
                    この画面が当日の入場チケットとなります。<br>
                    招待客の皆様は事前予約の必要はございません。当日はお名前、もしくはページ上部のテキスタイル画像・お名前付近をスクリーンショットなどで保存し、受付にてご提示ください。<br><br>
                    <span style="font-size: 0.9em; color: #555;">
                        ※もしご都合が合わず、ご来場が難しい場合は、お手数ですが各SNSやメール等で主催までご一報いただけますと幸いです。
                    </span>
                </div>
                <div style="display: flex; flex-direction: column; gap: 10px; align-items: center;">
                    <!-- VIP専用カレンダー登録ボタン（シェアボタンと同じUI） -->
                    <button class="share-btn" onclick="addToCalendar()"
                        style="width: 100%; max-width: 300px; background: #fff; color: #000; border: 1px solid #000; padding: 12px;">
                        ADD TO CALENDAR
                    </button>
                    <button class="share-btn" onclick="shareAttendanceToTwitter()"
                        style="width: 100%; max-width: 300px; background: #fff; color: #333; border: 1px solid #000; padding: 12px;">
                        SHARE ATTENDANCE
                    </button>
                    <button onclick="shareToInstagram()"
                        style="background:none; border:none; text-decoration:underline; font-size:9px; color:#999; cursor:pointer; margin-top: 5px;">
                        Download Textile Graphic Only
                    </button>
                </div>
            </div>

        </div>

        <!-- 共通詳細イベント情報セクション -->
        <div id="event-detail-section"
            style="margin-top: 50px; padding-top: 40px; border-top: 1px solid #000; width: 90%; max-width: 600px; text-align: left; font-family: 'DIN 2014', 'Noto Sans JP', sans-serif;">

            <!-- Link Buttons -->
            <div style="display: flex; gap: 10px; margin-bottom: 40px; justify-content: center; flex-wrap: wrap;">
                <a href="https://mautextileindustrylab.peatix.com/" target="_blank"
                    style="text-decoration: none; color: #fff; background: #000; padding: 10px 20px; font-size: 11px; font-weight: bold; letter-spacing: 0.1em; border-radius: 2px;">PEATIX</a>
                <a href="https://www.instagram.com/mau_textile_industry/" target="_blank"
                    style="text-decoration: none; color: #000; background: #fff; border: 1px solid #000; padding: 10px 20px; font-size: 11px; font-weight: bold; letter-spacing: 0.1em; border-radius: 2px;">INSTAGRAM</a>
                <a href="https://note.com/mautis" target="_blank"
                    style="text-decoration: none; color: #000; background: #fff; border: 1px solid #000; padding: 10px 20px; font-size: 11px; font-weight: bold; letter-spacing: 0.1em; border-radius: 2px;">NOTE</a>
            </div>

            <!-- Event Concept -->
            <div style="margin-bottom: 40px;">
                <h3 style="font-size: 16px; margin-bottom: 20px; letter-spacing: 0.1em;">EVENT INFORMATION</h3>
                <img src="main_visual.png" style="width: 100%; height: auto; margin-bottom: 25px; border-radius: 2px;"
                    alt="Event Main Visual">
                <div style="font-size: 14px; font-weight: bold; margin-bottom: 15px;">第一回 繊維産業研究報告会 -車と繊維-</div>
                <p style="font-size: 11px; line-height: 1.8; color: #333; margin-bottom: 15px;">
                    繊維には、物語があります。<br>
                    何度も使われ、味わいを帯びた繊維。誰にも触れられず、役目を果たせないまま廃棄される繊維。<br><br>
                    車の中にも、ひっそりと息づく繊維があります。シート、フロア、フィルター、クッション。私たちは、その物語を丁寧にすくい上げ、繊維が持つ新たな可能性を紡いでいきます。
                </p>
                <p style="font-size: 11px; line-height: 1.8; color: #333;">
                    本イベントは、武蔵野美術大学
                    繊維産業研究会による初の研究成果発表の場です。トヨタ紡織「RE:TERRACE」からの素材提供を受け、自動車用繊維素材を用いたファッションショー、および作品展示を行います。
                </p>
            </div>

            <!-- Practical Details Grid -->
            <div
                style="display: grid; grid-template-columns: 1fr; gap: 20px; margin-bottom: 40px; padding: 20px; background: #f9f9f9; border-radius: 4px;">
                <div>
                    <div style="font-size: 10px; color: #888; margin-bottom: 5px; font-weight: bold;">DATE & TIME</div>
                    <div style="font-size: 12px;">2026.02.28 SAT</div>
                    <div style="font-size: 11px; color: #555; margin-top: 5px;">
                        17:00 OPEN / 17:30 FASHION SHOW<br>
                        17:00 - 18:30 EXHIBITION
                    </div>
                </div>
                <div>
                    <div style="font-size: 10px; color: #888; margin-bottom: 5px; font-weight: bold;">VENUE</div>
                    <div style="font-size: 12px;">EVENT SPACE "MATERIAL"</div>
                    <div style="font-size: 10px; color: #555; margin-top: 3px;">東京都杉並区高円寺南4-4-11 (高円寺駅徒歩5分)</div>
                </div>
                <div>
                    <div style="font-size: 10px; color: #888; margin-bottom: 5px; font-weight: bold;">ADMISSION &
                        RESERVE
                    </div>
                    <div style="font-size: 12px;">500 JPY <span style="font-size: 10px; color:#888;">(CASH /
                            PAYPAY)</span>
                    </div>
                    <div style="font-size: 10px; color: #555; margin-top: 5px; font-weight: bold;">
                        ※事前予約特典：当日会場にて「特典ステッカー」を進呈。
                    </div>
                </div>
            </div>

            <!-- About Sections -->
            <div style="margin-bottom: 40px; font-size: 10px; line-height: 1.7; color: #666;">
                <div style="margin-bottom: 25px;">
                    <div style="font-weight: bold; color: #000; margin-bottom: 8px;">繊維産業研究会について</div>
                    私たちは、武蔵野美術大学を拠点とする、繊維産業に関する研究実験機関です。「繊維（Textile）」を、単なる衣服の素材としてではなく、社会や産業を構成するひとつの「基盤(infrastructure)」として捉え直すこと。素材・社会・産業への「接触(contact)」を起点に、美大生特有の視点で新たな文脈を探していきます。ファッション、舞台、インテリア、プロダクト、工芸、映像──
                    異なる領域の技術と視点を交差させながら、私たちは産業の新しい可能性を発見していきます。
                </div>
                <div style="margin-bottom: 25px;">
                    <div style="font-weight: bold; color: #000; margin-bottom: 8px;">トヨタ紡織 RE:TERRACEについて</div>
                    RE:TERRACEは、自動車用シート・内装を生産するトヨタ紡織が手掛けるアップサイクルブランド。生産工程で生じる廃棄予定の繊維素材を新たな製品としてよみがえらせる取組を行っています。本イベントでは、RE:TERRACEを通じて提供された素材を用い、研究・展示・表現の実験を行います。
                </div>
            </div>

            <!-- Footer Small -->
            <div
                style="border-top: 1px solid #eee; padding-top: 20px; margin-bottom: 50px; font-size: 9px; color: #999; text-align: center; letter-spacing: 0.1em;">
                <div style="margin-bottom: 5px;">ORGANIZER: MUSASHINO ART UNIVERSITY - TEXTILE INDUSTRY LABORATORY</div>
                <div style="margin-bottom: 15px;">SUPPORT: TOYOTA BOSHOKU CORPORATION / ICONIA HOSPITALITY K.K.</div>
                <div>CONTACT: mau.textile.industry@gmail.com</div>
            </div>

        </div>

    </div>

    <!-- テキスタイル生成用 高解像度Canvas (不可視) -->
    <canvas id="textileCanvas" width="2048" height="2048" style="display:none;"></canvas>
    </div>

    <script src="vip_list.js"></script>
    <script>
        // デバッグ用：エラーを画面に表示
        window.onerror = function (msg, url, line, col, error) {
            const caption = document.getElementById('caption');
            if (caption) caption.innerHTML = `<span style="color:red; font-size:12px;">ERROR: ${msg}<br>Line: ${line}</span>`;
            return false;
        };

        // --- 開発モード（true: PCでもアクセス可能） ---
        const DEV_MODE = false;  // 本番時は false に変更

        // --- デバイス制限チェック ---
        function checkDeviceAccess() {
            if (DEV_MODE) return;  // 開発モードはスキップ

            const deviceBlock = document.getElementById('device-block');
            const rotateBlock = document.getElementById('rotate-block');

            // モバイルデバイス判定（UA + タッチ + 画面幅の組み合わせ）
            const mobileUA = /Android|webOS|iPhone|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            const isIPad = /iPad/i.test(navigator.userAgent) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
            const hasTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
            const isSmallScreen = Math.min(window.innerWidth, window.innerHeight) <= 480;
            const isMobilePhone = (mobileUA && !isIPad) || (hasTouch && isSmallScreen && !isIPad);
            const isPortrait = window.innerHeight > window.innerWidth;

            // PC・iPad・大画面タブレット → ブロック
            if (!isMobilePhone) {
                deviceBlock.style.display = 'flex';
                rotateBlock.style.display = 'none';
                return;
            } else {
                deviceBlock.style.display = 'none';
            }

            // 横画面検出
            if (!isPortrait) {
                rotateBlock.style.display = 'flex';
            } else {
                rotateBlock.style.display = 'none';
            }
        }

        // 初期チェック＆リサイズ時に再チェック
        checkDeviceAccess();
        window.addEventListener('resize', checkDeviceAccess);
        window.addEventListener('orientationchange', () => {
            setTimeout(checkDeviceAccess, 200);  // orientationchange後の遅延で正確な値を取得
        });

        // --- Audio Control ---
        let isMuted = false;
        function toggleAudio() {
            isMuted = !isMuted;
            const bgm = window.bgm;
            const motor = window.motor;
            const narration = window.narration;

            if (bgm) bgm.muted = isMuted;
            if (motor) motor.muted = isMuted;
            if (narration) narration.muted = isMuted;

            const text = isMuted ? '( SOUND OFF )' : '( SOUND ON )';
            const gameText = isMuted ? 'SOUND OFF' : 'SOUND ON'; // HUDはシンプルに

            const indicator = document.getElementById('start-audio-indicator');
            if (indicator) indicator.innerHTML = text;

            const gameBtn = document.getElementById('game-audio-btn');
            if (gameBtn) {
                gameBtn.innerHTML = gameText;
                gameBtn.style.opacity = isMuted ? '0.5' : '1.0';
            }
        }

        // --- コラボレーション: 緯糸モード検出 & VIP判定 ---
        window.isWeftMode = false;
        window.warpDataFromUrl = null;
        window.isVip = false;
        window.vipData = null;

        // VIPリスト (外部ファイルから読み込み)
        // vip_list.js で window.VIP_LIST が定義されています
        const VIP_LIST = window.VIP_LIST || {};

        // --- ストレージキー取得ヘルパー ---
        function getStorageKey() {
            const urlParams = new URLSearchParams(window.location.search);
            const vipId = urlParams.get('vip');
            const warpParam = urlParams.get('warp');

            if (vipId && VIP_LIST[vipId]) {
                return `mautil_result_${vipId}`;
            } else if (warpParam) {
                // 招待リンク(緯糸モード)の場合、リンクごとにキーを分ける (先頭12文字をハッシュ代わりに)
                const hash = warpParam.substring(0, 12).replace(/[^a-zA-Z0-9]/g, '');
                return `mautil_result_weft_${hash}`;
            } else {
                // 通常のホストプレイ
                return `mautil_result_guest`;
            }
        }

        function restoreFromStorage() {
            const urlParams = new URLSearchParams(window.location.search);

            // 1. VIP判定
            const vipId = urlParams.get('vip');
            if (vipId && VIP_LIST[vipId]) {
                window.isVip = true;
                window.vipData = VIP_LIST[vipId];
                console.log('VIPモードで起動:', window.vipData);

                // ブラウザタイトル更新
                document.title = `INVITATION FOR ${window.vipData.name} | 繊維産業研究報告会`;

                // スタート画面の表示更新
                const eventTitle = document.querySelector('#start-screen .event-title');
                const eventDate = document.querySelector('#start-screen .event-date');

                if (eventTitle) {
                    eventTitle.innerHTML = `<span style="font-size: 0.6em; display:block; margin-bottom:5px; opacity:0.7;">WELCOME</span>${window.vipData.name}<br><span style="font-size: 0.5em; opacity: 0.8;">- ${window.vipData.role} -</span>`;
                }
                if (eventDate) {
                    eventDate.style.borderTop = "none";
                    eventDate.innerHTML = "YOUR EXCLUSIVE TICKET RESERVATION";
                }
            }

            // 2. 緯糸モード判定 (VIPでない場合のみ有効)
            const warpParam = urlParams.get('warp');
            if (!window.isVip && warpParam) {
                try {
                    const decoded = atob(warpParam);
                    const parsed = JSON.parse(decoded);
                    // 復元（短縮キー対応）
                    window.warpDataFromUrl = decompressWarpData(parsed);

                    window.isWeftMode = true;
                    console.log('緯糸モードで起動:', window.warpDataFromUrl);

                    // ブラウザタイトル更新
                    document.title = "YOUR TEXTILE INVITATION | 繊維産業研究報告会";

                    // スタート画面に緯糸モード表示
                    const weftInfo = document.getElementById('weft-mode-info');
                    const startHint = document.getElementById('start-hint');
                    if (weftInfo) weftInfo.style.display = 'block';
                    if (startHint) startHint.innerHTML = 'タップして緯糸を織り始める';
                } catch (e) {
                    console.error('経糸データのデコードに失敗:', e);
                }
            }

            // 3. 過去の保存データ確認 (Persistence)
            const storageKey = getStorageKey();
            const savedDataJson = localStorage.getItem(storageKey);

            if (savedDataJson) {
                try {
                    const savedData = JSON.parse(savedDataJson);
                    // --- 復元スキップ判定 (招待リンク踏んだ時) ---
                    // もし「緯糸モード(招待)で起動」していて、かつ「保存データが緯糸モードの結果ではない（経糸の結果）」なら
                    // 復元せずに新規ゲーム (緯糸プレイ) を開始する。
                    // ※ savedData.playMode がない場合は古いデータ(経糸)とみなす
                    // 修正: デコード失敗時なども考慮し、isWeftModeフラグではなくパラメータの有無で判定
                    if (warpParam && savedData.playMode !== 'weft') {
                        console.log('招待リンクからのアクセスのため、過去の経糸データを無視して新規ゲームを開始します。');
                        return false;
                    }

                    // 必須データの検証
                    if (!savedData || !savedData.genParams) {
                        throw new Error("Invalid saved data");
                    }

                    console.log('保存された結果を復元:', savedData);

                    // データ復元
                    window.genParams = savedData.genParams;
                    window.diagnosisResults = savedData.diagnosisResults;
                    if (savedData.diagnosisParams) window.diagnosisParams = savedData.diagnosisParams; // 詳細パラメータ復元
                    if (savedData.diagnosisParams) window.diagnosisParams = savedData.diagnosisParams; // 詳細パラメータ復元
                    if (savedData.vipData) window.vipData = savedData.vipData;
                    if (savedData.vipColors) window.vipColors = savedData.vipColors;

                    // モード情報の復元 (重要: ここでフラグを立てることでリロード復元を担保)
                    if (savedData.playMode === 'weft') {
                        window.isWeftMode = true;
                        document.title = "YOUR TEXTILE | 繊維産業研究報告会";
                    }
                    if (savedData.playMode === 'vip') {
                        window.isVip = true;
                        if (window.vipData) {
                            document.title = `INVITATION FOR ${window.vipData.name} | 繊維産業研究報告会`;
                        }
                    }

                    // 起動時即リザルト画面へ
                    restoreResultScreen();
                    return true;
                } catch (e) {
                    console.error('保存データの読み込み失敗 (自動削除):', e);
                    localStorage.removeItem(storageKey);
                }
            }
            return false;
        }

        // --- 設定エリア ---
        // --- 設定エリア (Game Configuration) ---
        const GameConfig = {
            renderScale: 0.5,      // 画質調整（軽くするために半分で計算して拡大）
            roadWidth: 2000,
            segmentLength: 200,
            rumbleLength: 3,
            fieldOfView: 100,
            cameraHeight: 300,
            drawDistance: 300,
            // 物理挙動
            physics: {
                maxSpeed: 18000,   // 最高速度 (1.5倍)
                accel: 23,         // 加速度 (1.5倍)
                breaking: -300,    // 減速度 (1.5倍)
                decel: -75,        // 自然減速 (1.5倍)
                offRoadDecel: -300,// コースアウト減速 (1.5倍)
                offRoadLimit: 3000,// コースアウト判定幅 (1.5倍)
                speedMultiplier: 0.006 // 移動係数 (元に戻す：speed自体が増えているため)
            }
        };

        // 後方互換性（既存コードを壊さないためのエイリアス）
        // ※徐々に GameConfig.XXX に置き換えていく
        const renderScale = GameConfig.renderScale;
        const roadWidth = GameConfig.roadWidth;
        const segmentLength = GameConfig.segmentLength;
        const rumbleLength = GameConfig.rumbleLength;
        const fieldOfView = GameConfig.fieldOfView;
        let cameraHeight = GameConfig.cameraHeight; // letのまま
        const drawDistance = GameConfig.drawDistance;

        // --- エンジン変数 ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const caption = document.getElementById('caption');
        const speedValue = document.getElementById('speedValue');

        let width, height;
        let position = 0;
        let playerX = 0;
        let playerZ = 0;
        let speed = 0;

        // エイリアス（物理）
        const speedMultiplier = GameConfig.physics.speedMultiplier;
        const maxSpeed = GameConfig.physics.maxSpeed;
        const accel = GameConfig.physics.accel;
        const breaking = GameConfig.physics.breaking;
        const decel = GameConfig.physics.decel;
        const offRoadDecel = GameConfig.physics.offRoadDecel;
        const offRoadLimit = GameConfig.physics.offRoadLimit;

        let keyLeft = false;
        let keyRight = false;
        let keyFaster = true; // 自動アクセルON

        // スマホタッチ制御用グローバル変数
        let isMobile = false;
        let lastTouchX = 0;
        let touchSteerDir = 0; // -1=左, 0=直進, 1=右

        // --- ゲーム状態管理 ---
        let gameState = 'start'; // 'start', 'playing', 'result'

        // --- プレイデータ収集 ---
        const gameDuration = 30000; // 30秒
        let gameStartTime = null;
        let gameEnded = false;
        let playData = {
            weaveType: 0,
            texture: 0,
            density: 0,
            steeringHistory: [],
            speedHistory: [],
            trajectory: [],
            collisionCount: 0,
            steeringFlipCount: 0, // 追加: 初期化
            totalDistance: 0,
            itemCounts: { blue: 0, red: 0, green: 0, orange: 0 }
        };

        // 蛇行度計算用
        let lastPlayerX = 0;
        let steeringVariance = 0;
        let steeringInputSum = 0;
        let steeringFlipCount = 0;
        let lastSteerDir = 0;

        // 画像
        // 画像 (Globals) - src設定はinitで行うか、ここで設定してPreloaderで監視する
        const carImgStraight = new Image();
        const carImgLeft = new Image();
        const carImgRight = new Image();

        // 車のカラーフィルター（アイテム取得で変化）
        let carColorHue = 0;  // 0=通常, 180=青, 330=赤, 90=緑, 30=オレンジ
        let carColorSaturate = 1.0; // 彩度

        // 最後に取得したカラーアイテム（結果画面に反映）
        let lastCollectedColor = 'black';  // デフォルトは黒

        // 障害物画像
        const obstacleSources = ['dram.png', 'dram2.png', 'wall.png', 'wall2.png'];
        const obstacleImgs = obstacleSources.map(src => new Image()); // 空のImageを作成

        // 道路データ
        const segments = [];
        const totalSegments = 1600;

        // 障害物・アイテムデータ
        const obstacles = [];
        const items = []; // カラーアイテム

        // 音声オブジェクト (グローバル事前生成)
        const audioAssets = {
            bgm: new Audio(),
            motor: new Audio(),
            narration: new Audio()
        };
        // 設定
        audioAssets.bgm.loop = true;
        audioAssets.bgm.volume = 0.5;
        audioAssets.motor.loop = true;
        audioAssets.motor.volume = 0.6;
        audioAssets.narration.volume = 1.0;

        // グローバル参照へ紐付け (互換性維持)
        window.bgm = audioAssets.bgm;
        window.motor = audioAssets.motor;
        window.narration = audioAssets.narration;

        function initObstacles(startSegmentIndex = 0) {
            obstacles.length = 0;
            // 障害物をランダムに配置 (指定位置以降)
            const count = 40;
            for (let i = 0; i < count; i++) {
                // 開始位置から全周の範囲で配置
                const offset = Math.floor(Math.random() * totalSegments);
                const idx = (startSegmentIndex + offset) % totalSegments;

                // 目の前(スタート直後)すぎる場合は避ける (例えば +50 セグメント以降)
                if (Math.abs(idx - startSegmentIndex) < 50) continue;

                obstacles.push({
                    segmentIndex: idx,
                    x: (Math.random() - 0.5) * 1.5,
                    type: Math.floor(Math.random() * obstacleImgs.length),
                    hit: false
                });
            }
        }

        function initItems(startSegmentIndex = 0) {
            items.length = 0;
            // 6色システム
            const colors = ['monochrome', 'red', 'blue', 'green', 'orange', 'purple'];
            const count = 20;
            for (let i = 0; i < count; i++) {
                const offset = Math.floor(Math.random() * totalSegments);
                const idx = (startSegmentIndex + offset) % totalSegments;

                if (Math.abs(idx - startSegmentIndex) < 50) continue;

                items.push({
                    segmentIndex: idx,
                    x: (Math.random() - 0.5) * 1.8,
                    color: colors[Math.floor(Math.random() * colors.length)],
                    hit: false,
                    floatOffset: Math.random() * Math.PI * 2
                });
            }
        }

        // --- 数学関数 ---
        function project(p, cameraX, cameraY, cameraZ, cameraDepth) {
            p.camera.x = (p.world.x || 0) - cameraX;
            p.camera.y = (p.world.y || 0) - cameraY;
            p.camera.z = (p.world.z || 0) - cameraZ;
            p.screen.scale = cameraDepth / p.camera.z;
            p.screen.x = Math.round((width / 2) + (p.screen.scale * p.camera.x * width / 2));
            p.screen.y = Math.round((height / 2) - (p.screen.scale * p.camera.y * height / 2));
            p.screen.w = Math.round((p.screen.scale * roadWidth * width / 2));
        }

        function easeIn(a, b, percent) { return a + (b - a) * Math.pow(percent, 2); }
        function easeOut(a, b, percent) { return a + (b - a) * (1 - Math.pow(1 - percent, 2)); }
        function easeInOut(a, b, percent) { return a + (b - a) * ((-Math.cos(percent * Math.PI) / 2) + 0.5); }

        // --- 道路生成 ---
        function addSegment(curve) {
            const n = segments.length;
            segments.push({
                index: n,
                p1: { world: { z: n * segmentLength }, camera: {}, screen: {} },
                p2: { world: { z: (n + 1) * segmentLength }, camera: {}, screen: {} },
                curve: curve,
                color: Math.floor(n / rumbleLength) % 2 ? '#222' : '#111'
            });
        }

        function addRoad(enter, hold, leave, curve) {
            for (let n = 0; n < enter; n++) addSegment(easeIn(0, curve, n / enter));
            for (let n = 0; n < hold; n++) addSegment(curve);
            for (let n = 0; n < leave; n++) addSegment(easeInOut(curve, 0, n / leave));
        }

        function initRoad() {
            addRoad(50, 50, 50, 0);       // 直線
            addRoad(50, 50, 50, 4);       // 右カーブ
            addRoad(50, 50, 50, -2);      // 左カーブ
            addRoad(50, 50, 50, 2);       // 右へ
            addRoad(50, 200, 50, 0);      // 長い直線
            addRoad(50, 50, 50, -4);      // きつい左
            addRoad(100, 100, 100, 0);    // 最後は直線
        }

        // --- 初期化 ---
        function init() {
            resize();
            window.addEventListener('resize', resize);

            // 操作系
            window.addEventListener('keydown', e => {
                if (gameState !== 'playing') return;
                if (e.key === 'ArrowLeft') keyLeft = true;
                if (e.key === 'ArrowRight') keyRight = true;
            });
            window.addEventListener('keyup', e => {
                if (e.key === 'ArrowLeft') keyLeft = false;
                if (e.key === 'ArrowRight') keyRight = false;
            });

            // スマホタッチ制御
            function updateTouchSteering(touchX) {
                const normalizedX = (touchX / width) * 2 - 1;
                touchSteerDir = Math.max(-1, Math.min(1, normalizedX));
            }

            canvas.addEventListener('touchstart', e => {
                if (gameState !== 'playing') return;
                isMobile = true;
                updateTouchSteering(e.touches[0].clientX);
            }, { passive: false });

            canvas.addEventListener('touchmove', e => {
                if (gameState !== 'playing') return;
                e.preventDefault();
                updateTouchSteering(e.touches[0].clientX);
            }, { passive: false });

            canvas.addEventListener('touchend', e => {
                if (gameState === 'ready') {
                    // READY状態ならタップでゲーム開始
                    startGame();
                } else if (gameState === 'playing') {
                    touchSteerDir = 0;
                }
            });

            // PC用マウスイベント（クリック/タップ対応）
            canvas.addEventListener('mousedown', e => {
                if (gameState === 'ready') {
                    startGame();
                }
            });

            // SKIPボタンイベント
            document.getElementById('skip-btn').addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (gameState === 'opening') {
                    endOpening();
                }
            });

            // --- VIP判定 & 復元を最優先で実行 (即時表示のため) ---
            const isRestored = restoreFromStorage();

            if (isRestored) {
                console.log('Restored to result screen via storage');
            } else {
                console.log('App initialized on start screen');
            }

            // init時点ではアセットをロードせず、STARTボタンが押された時にロードを開始するように変更
            // ただし、バックグラウンドでのロードも検討したが、ユーザーの要望により
            // 「STARTを押してからロード」というフローに明確に分離する




            // BGM設定 (プリロードで既にロード済み)

            // スタート画面のボタン - シンプルかつ堅牢にリトライ再生
            document.getElementById('init-button').addEventListener('click', () => {
                // ローディングオーバーレイを表示
                const loader = document.getElementById('loading-overlay');
                if (loader) {
                    loader.style.display = 'flex';
                    loader.style.opacity = '1';
                }

                // プリロード開始
                preloadAssets().then(() => {
                    console.log('Asset loading completed post-START');

                    // ローディング画面を隠す
                    if (loader) {
                        loader.style.opacity = '0';
                        setTimeout(() => {
                            loader.style.display = 'none';
                        }, 500);
                    }

                    const playAudio = (audio) => {
                        if (audio.readyState >= 3) { // HAVE_FUTURE_DATA
                            audio.play().catch(e => console.warn('Play failed', e));
                        } else {
                            audio.load();
                            audio.play().catch(e => console.warn('Force load play failed', e));
                        }
                    };

                    playAudio(window.bgm);
                    // ナレーション開始のタイミング（ミリ秒）。字幕とズレる場合はここを調整してください。
                    const narrationDelay = 1400;
                    setTimeout(() => {
                        playAudio(window.narration);
                    }, narrationDelay);

                    startGameTransition();
                });
            });

            initRoad();
            initObstacles();
            initItems();

            requestAnimationFrame(loop);
        }

        // --- アセットプリロード ---
        function preloadAssets() {
            const progress = document.getElementById('loading-progress');
            let loadedCount = 0;
            const imagesToLoad = [
                { img: carImgStraight, src: 'car_straight.png' },
                { img: carImgLeft, src: 'car2_left.png' },
                { img: carImgRight, src: 'car2_right.png' }
            ];

            // 障害物
            obstacleImgs.forEach((img, i) => {
                imagesToLoad.push({ img: img, src: obstacleSources[i] });
            });

            // 音声ソース定義
            const audioSources = [
                { audio: window.bgm, src: 'bgm.wav' },
                { audio: window.motor, src: 'car_bgm.wav' },
                { audio: window.narration, src: 'ElevenLabs_2026-02-03T08_23_36_Relaxing Rachel - Calm & Soothing_pvc_sp75_s100_sb75_se27_b_m2.mp3' }
            ];

            const totalAssets = imagesToLoad.length + audioSources.length;

            const updateProgress = () => {
                loadedCount++;
                const pct = Math.floor((loadedCount / totalAssets) * 100);
                if (progress) progress.style.width = `${pct}%`;
            };

            const imagePromises = imagesToLoad.map(item => {
                return new Promise(resolve => {
                    item.img.onload = () => { updateProgress(); resolve(); };
                    item.img.onerror = () => { console.warn('Image load error:', item.src); updateProgress(); resolve(); };
                    item.img.src = item.src;
                });
            });

            // 音声のプリロード (canplaythrough待機)
            const audioPromises = audioSources.map(item => {
                return new Promise(resolve => {
                    const onReady = () => {
                        updateProgress();
                        item.audio.removeEventListener('canplaythrough', onReady);
                        resolve();
                    };

                    item.audio.addEventListener('canplaythrough', onReady);
                    item.audio.addEventListener('error', (e) => {
                        console.warn('Audio load error:', item.src, e);
                        updateProgress(); // エラーでも進行させる
                        resolve();
                    });

                    // ファイルセット・ロード開始
                    item.audio.src = item.src;
                    item.audio.load();
                });
            });

            return Promise.all([...imagePromises, ...audioPromises]);
        }

        function startGameTransition() {
            const startScreen = document.getElementById('start-screen');
            startScreen.style.transition = 'opacity 0.5s';
            startScreen.style.opacity = '0';

            setTimeout(() => {
                startScreen.classList.add('hidden');
                startScreen.style.display = 'none'; // 確実に非表示
                // ここでいきなりstartGameではなく、Openingを開始
                startOpening();
            }, 500);
        }

        // --- 新しいフェーズ管理関数 ---

        function startOpening() {
            gameState = 'opening';
            gameStartTime = Date.now(); // 追加: 字幕用タイマー初期化

            // 車の色を白（モノクロ）にリセット
            lastCollectedColor = 'monochrome';
            carColorHue = 0;
            carColorSaturate = 0;

            document.getElementById('audio-controls').style.display = 'block';
            document.getElementById('skip-btn').style.display = 'block';

            // スピードメーター位置調整（常時中央になったので削除）
            // const speedMeter = document.getElementById('speedometer');
            // if (speedMeter) speedMeter.classList.add('center-top');

            // 字幕初期化
            const cap = document.getElementById('caption');
            if (cap) {
                cap.innerHTML = "";
                cap.style.opacity = '1';
            }

            // ナレーション終了検知
            window.narration.onended = () => {
                if (gameState === 'opening') {
                    endOpening();
                }
            };

            // オートラン速度設定 (ゆっくり)
            speed = 100;

            // 障害物は空にする
            obstacles.length = 0;
            items.length = 0;
        }

        function endOpening() {
            gameState = 'ready';
            document.getElementById('skip-btn').style.display = 'none';

            // スピードメーター位置戻す（常時中央なので削除）
            // const speedMeter = document.getElementById('speedometer');
            // if (speedMeter) speedMeter.classList.remove('center-top');

            // ナレーション停止
            window.narration.pause();
            window.narration.currentTime = 0;
            window.narration.onended = null;

            // TAP TO START 表示
            const tapMsg = document.getElementById('tap-to-start');
            tapMsg.style.display = 'block';
        }

        function startGame() {
            // TAP TO START 非表示
            document.getElementById('tap-to-start').style.display = 'none';

            gameState = 'playing';

            // エンジン音開始
            if (window.motor) {
                window.motor.play().catch(e => console.warn('Motor play failed', e));
            }

            gameStartTime = Date.now();
            lastTime = gameStartTime; // デルタタイム計算用
            gameEnded = false;

            // ホワイトアウトリセット
            const wo = document.getElementById('whiteout-overlay');
            if (wo) wo.style.opacity = '0';

            // 音量リセット（フェードアウト後用）
            if (window.bgm) window.bgm.volume = 0.5;
            if (window.motor) window.motor.volume = 0.6;

            // データリセット/初期化
            playData = {
                weaveType: 0,
                texture: 0,
                density: 0,
                steeringHistory: [],
                speedHistory: [],
                trajectory: [],
                collisionCount: 0,
                steeringFlipCount: 0, // 追加: リセット
                totalDistance: 0,
                itemCounts: { blue: 0, red: 0, green: 0, orange: 0 }
            };
            lastPlayerX = playerX; // 現在位置を維持
            // steeringVariance = 0; // そのまま
            steeringInputSum = 0;
            steeringFlipCount = 0;
            lastSteerDir = 0;

            // ポジション維持 (position = 0 を削除)
            // 道路生成もしない (initRoad 削除)

            // 障害物とアイテムのみ再配置（現在の位置より先から）
            const currentSegIndex = Math.floor(position / segmentLength) % totalSegments;
            initObstacles(currentSegIndex);
            initItems(currentSegIndex);

            // 車のカラーリセット
            carColorHue = 0;
            carColorSaturate = 1.0;
            lastCollectedColor = 'monochrome';  // リセット（白＝黒糸）
            window.glitchIntensity = 0; // グリッチ初期化

            // 操作ヒント表示（3秒後に消える）
            const hint = document.getElementById('control-hint');
            if (hint) {
                hint.style.display = 'block';
                hint.style.opacity = '1';
                hint.style.transition = 'opacity 0.5s';
                setTimeout(() => {
                    hint.style.opacity = '0';
                    setTimeout(() => { hint.style.display = 'none'; }, 500);
                }, 4000); // 1500から4000(4秒)に延長
            }
        }

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            ctx.imageSmoothingEnabled = false;
        }

        // --- 描画ループ ---
        function render() {
            // playing, opening, ready のいずれかなら描画する
            if (gameState !== 'playing' && gameState !== 'opening' && gameState !== 'ready') return;

            ctx.clearRect(0, 0, width, height);
            ctx.fillStyle = '#fff';
            ctx.fillRect(0, 0, width, height);

            const baseSegment = segments[Math.floor(position / segmentLength) % segments.length];
            const basePercent = (position % segmentLength) / segmentLength;
            const playerSegment = segments[Math.floor((position + playerZ) / segmentLength) % segments.length];
            const playerPercent = ((position + playerZ) % segmentLength) / segmentLength;

            let dx = -(baseSegment.curve * basePercent);
            let x = 0;
            const cameraDepth = 1 / Math.tan((fieldOfView / 2) * Math.PI / 180);

            let maxy = height;
            const projected = new Array(totalSegments);

            for (let n = 0; n < drawDistance; n++) {
                const segment = segments[(baseSegment.index + n) % segments.length];

                segment.p1.camera.x = playerX * roadWidth;
                project(segment.p1, (playerX * roadWidth) - x, cameraHeight, position - (segment.index < baseSegment.index ? totalSegments * segmentLength : 0), cameraDepth);

                x += dx;
                dx += segment.curve;

                project(segment.p2, (playerX * roadWidth) - x - dx, cameraHeight, position - (segment.index < baseSegment.index ? totalSegments * segmentLength : 0), cameraDepth);

                if (segment.p1.camera.z <= cameraDepth || segment.p2.screen.y >= segment.p1.screen.y || segment.p2.screen.y >= maxy) continue;

                ctx.fillStyle = segment.color;
                ctx.beginPath();
                ctx.moveTo(segment.p1.screen.x - segment.p1.screen.w, segment.p1.screen.y);
                ctx.lineTo(segment.p2.screen.x - segment.p2.screen.w, segment.p2.screen.y);
                ctx.lineTo(segment.p2.screen.x + segment.p2.screen.w, segment.p2.screen.y);
                ctx.lineTo(segment.p1.screen.x + segment.p1.screen.w, segment.p1.screen.y);
                ctx.fill();

                if (n % 5 === 0) {
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(segment.p1.screen.x - segment.p1.screen.w, segment.p1.screen.y);
                    ctx.lineTo(segment.p2.screen.x - segment.p2.screen.w, segment.p2.screen.y);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(segment.p1.screen.x + segment.p1.screen.w, segment.p1.screen.y);
                    ctx.lineTo(segment.p2.screen.x + segment.p2.screen.w, segment.p2.screen.y);
                    ctx.stroke();
                }

                ctx.strokeStyle = '#444';
                ctx.lineWidth = 1;
                ctx.setLineDash([10, 10]);
                ctx.beginPath();
                ctx.moveTo(segment.p1.screen.x, segment.p1.screen.y);
                ctx.lineTo(segment.p2.screen.x, segment.p2.screen.y);
                ctx.stroke();
                ctx.setLineDash([]);

                projected[segment.index] = {
                    x: segment.p2.screen.x,
                    y: segment.p2.screen.y,
                    w: segment.p2.screen.w
                };
                maxy = segment.p1.screen.y;
            }

            // 障害物描画
            obstacles.forEach(obstacle => {
                // OPENING/READY中は障害物を描画しない（そもそも空だが念のため）
                if (gameState !== 'playing') return;

                if (obstacle.hit) return;
                const p = projected[obstacle.segmentIndex];
                if (!p) return;

                const obstacleScreenX = p.x + (obstacle.x * p.w);
                const obstacleScreenY = p.y;

                // 画像描画
                const img = obstacleImgs[obstacle.type];
                let obsWidth = 0;
                let obsHeight = 0;

                if (img && img.complete && img.width > 0) {
                    // スケーリング：道路幅(p.w)の25%程度に合わせる
                    const targetWidth = p.w * 0.4;
                    const scale = targetWidth / img.width;
                    obsWidth = targetWidth;
                    obsHeight = img.height * scale;

                    const drawX = obstacleScreenX - obsWidth / 2;
                    const drawY = obstacleScreenY - obsHeight * 1; // より路面に近く

                    ctx.drawImage(img, drawX, drawY, obsWidth, obsHeight);
                } else {
                    // 読み込み前フォールバック
                    const radius = Math.max(6, 0.5 * p.w * 0.03 * 300);
                    ctx.fillStyle = '#f00';
                    ctx.beginPath();
                    ctx.arc(obstacleScreenX, obstacleScreenY, radius, 0, Math.PI * 2);
                    ctx.fill();
                    obsWidth = radius * 2;
                }

                // 衝突判定
                const playerScreenX = width / 2;
                const playerScreenY = height - 120;

                // 判定エリア（画像幅の40%）
                const hitRadius = Math.max(20, obsWidth * 0.4);

                // Y座標判定
                const inDepthRange = (obstacleScreenY > playerScreenY - 40) && (obstacleScreenY < playerScreenY + 60);

                if (inDepthRange && Math.abs(playerScreenX - obstacleScreenX) < hitRadius + 40) {
                    playData.collisionCount += 2;
                    obstacle.hit = true;
                    speed = Math.max(0, speed - 8000);

                    // グリッチエフェクト発動
                    window.glitchIntensity = 1.0;

                    // 衰突演出（白に戻す）
                    const flash = document.createElement('div');
                    flash.style.cssText = 'position:fixed;top:0;left:0;width:100vw;height:100vh;background:rgba(255,255,255,0.8);pointer-events:none;z-index:999;transition:opacity 0.15s;mix-blend-mode:normal;';
                    document.body.appendChild(flash);
                    requestAnimationFrame(() => {
                        flash.style.opacity = '0';
                        setTimeout(() => flash.remove(), 150);
                    });
                }
            });

            // アイテム描画
            items.forEach(item => {
                if (item.hit) return;
                const p = projected[item.segmentIndex];
                if (!p) return;

                const floatY = Math.sin(Date.now() / 400 + item.floatOffset) * 3; // 揺れ控えめ
                const itemScreenX = p.x + (item.x * p.w);
                // 高さ調整：1.5 -> 0.3 (だいぶ下げる)
                const itemScreenY = p.y - p.w * 0.1 - floatY * (p.w * 0.005);
                const size = p.w * 0.05;

                ctx.save();
                ctx.translate(itemScreenX, itemScreenY);

                // 6色パレット（白背景で映える色）
                const colorMap = {
                    monochrome: { code: '#ffffff', glow: 'rgba(255, 255, 255, 0.8)' },
                    red: { code: '#e60012', glow: 'rgba(230, 0, 18, 0.6)' },
                    blue: { code: '#0066cc', glow: 'rgba(0, 102, 204, 0.6)' },
                    green: { code: '#009944', glow: 'rgba(0, 153, 68, 0.6)' },
                    orange: { code: '#ff6600', glow: 'rgba(255, 102, 0, 0.6)' },
                    purple: { code: '#6b0099', glow: 'rgba(107, 0, 153, 0.6)' }
                };
                const colorInfo = colorMap[item.color] || colorMap.monochrome;
                const colorCode = colorInfo.code;
                const glowCode = colorInfo.glow;

                ctx.shadowBlur = 30;
                ctx.shadowColor = colorCode;
                ctx.fillStyle = colorCode;
                ctx.beginPath();
                ctx.moveTo(0, -size);
                ctx.lineTo(size * 0.8, 0);
                ctx.lineTo(0, size);
                ctx.lineTo(-size * 0.8, 0);
                ctx.closePath();
                ctx.fill();

                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.moveTo(0, -size * 0.5);
                ctx.lineTo(size * 0.4, 0);
                ctx.lineTo(0, size * 0.5);
                ctx.lineTo(-size * 0.4, 0);
                ctx.closePath();
                ctx.globalAlpha = 0.5;
                ctx.fill();

                ctx.restore();

                // 取得判定
                const playerScreenX = width / 2;
                const playerScreenY = height - 120;
                const distanceToItem = Math.hypot(playerScreenX - itemScreenX, playerScreenY - itemScreenY);

                if (distanceToItem < size + 100 && p.w > 10) {
                    if (playData && playData.itemCounts) {
                        playData.itemCounts[item.color] = (playData.itemCounts[item.color] || 0) + 1;
                    }
                    item.hit = true;

                    // 最後に取得した色を記録（結果画面で使用）
                    lastCollectedColor = item.color;

                    // 車のカラーフィルター変更（6色対応）
                    const carFilterMap = {
                        monochrome: { hue: 0, saturate: 0 },      // 白（彩度0で白化処理へ）
                        red: { hue: 330, saturate: 1.5 },
                        blue: { hue: 180, saturate: 1.5 },
                        green: { hue: 90, saturate: 1.5 },
                        orange: { hue: 30, saturate: 1.5 },
                        purple: { hue: 270, saturate: 1.5 }
                    };
                    const filter = carFilterMap[item.color] || carFilterMap.monochrome;
                    carColorHue = filter.hue;
                    carColorSaturate = filter.saturate;

                    try {
                        const originalRate = window.motor.playbackRate;
                        window.motor.playbackRate = 2.0;
                        setTimeout(() => window.motor.playbackRate = originalRate, 150);
                    } catch (e) { }
                }
            });

            // 車の描画
            let currentCarImg = carImgStraight;
            if (isMobile) {
                if (touchSteerDir < -0.2) currentCarImg = carImgLeft;
                else if (touchSteerDir > 0.2) currentCarImg = carImgRight;
            } else {
                if (keyLeft) currentCarImg = carImgLeft;
                else if (keyRight) currentCarImg = carImgRight;
            }

            if (currentCarImg.complete) {
                let carScale = 0.4;
                if (cameraHeight < 800) carScale = 0.65;

                const carDisplayWidth = width * carScale;
                const ratio = currentCarImg.height / currentCarImg.width;
                const carDisplayHeight = carDisplayWidth * ratio;
                const carX = (width / 2) - (carDisplayWidth / 2);
                const bounce = Math.sin(Date.now() / 50) * 2;
                const carY = height - carDisplayHeight - 20 + bounce;

                ctx.save();
                ctx.beginPath();
                const shadowX = carX + carDisplayWidth / 2;
                const shadowY = height - 80 + bounce;
                const shadowRadiusX = carDisplayWidth * 0.45;
                const shadowRadiusY = 35;
                ctx.ellipse(shadowX, shadowY, shadowRadiusX, shadowRadiusY, 0, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(0, 0, 0, 0.25)';
                ctx.fill();
                ctx.restore();

                // 車の描画（一度白くして、その上から着色する）

                // オフスクリーンキャンバスの準備
                if (!window.carTintCanvas) {
                    window.carTintCanvas = document.createElement('canvas');
                    window.carTintCtx = window.carTintCanvas.getContext('2d');
                }

                // サイズ調整＆クリア
                if (window.carTintCanvas.width !== Math.ceil(carDisplayWidth) || window.carTintCanvas.height !== Math.ceil(carDisplayHeight)) {
                    window.carTintCanvas.width = Math.ceil(carDisplayWidth);
                    window.carTintCanvas.height = Math.ceil(carDisplayHeight);
                }
                const tCtx = window.carTintCtx;
                tCtx.clearRect(0, 0, window.carTintCanvas.width, window.carTintCanvas.height);

                // 1. 車の画像をオフスクリーンに描画
                tCtx.globalCompositeOperation = 'source-over';
                tCtx.drawImage(currentCarImg, 0, 0, carDisplayWidth, carDisplayHeight);

                // 2. 「白化」処理（赤を白にする）
                // lightenなどで白を重ねて明るくし、saturationで彩度を抜く
                tCtx.globalCompositeOperation = 'screen';
                tCtx.fillStyle = '#ffffff';
                tCtx.fillRect(0, 0, window.carTintCanvas.width, window.carTintCanvas.height);

                tCtx.globalCompositeOperation = 'saturation';
                tCtx.fillStyle = '#ffffff'; // 白（無彩色）
                tCtx.fillRect(0, 0, window.carTintCanvas.width, window.carTintCanvas.height);

                // 3. 元の車の形で切り抜く（マスク）
                tCtx.globalCompositeOperation = 'destination-in';
                tCtx.drawImage(currentCarImg, 0, 0, carDisplayWidth, carDisplayHeight);

                // --- これで tintCanvas には「白い車」が入っている状態 ---

                // 4. ここに着色を行う
                let targetColor = lastCollectedColor;
                if (!targetColor) targetColor = 'red'; // デフォルト赤

                if (targetColor !== 'monochrome') {
                    // 色定義
                    let overlayColor = 'rgba(255, 0, 50, 1.0)'; // デフォルト赤（濃いめ）
                    if (targetColor === 'blue') overlayColor = 'rgba(0, 100, 255, 1.0)';
                    else if (targetColor === 'green') overlayColor = 'rgba(0, 200, 50, 1.0)';
                    else if (targetColor === 'orange') overlayColor = 'rgba(255, 120, 0, 1.0)';
                    else if (targetColor === 'purple') overlayColor = 'rgba(150, 0, 200, 1.0)';
                    else if (targetColor === 'red') overlayColor = 'rgba(255, 0, 50, 1.0)';

                    // 白い車に色を乗せる (multiply + source-atop)
                    tCtx.globalCompositeOperation = 'multiply';
                    tCtx.fillStyle = overlayColor;
                    tCtx.fillRect(0, 0, window.carTintCanvas.width, window.carTintCanvas.height);

                    // 発色を良くするためにoverlayも重ねる
                    tCtx.globalCompositeOperation = 'source-atop';
                    tCtx.fillStyle = overlayColor;

                    // マスク再適用
                    tCtx.globalCompositeOperation = 'destination-in';
                    tCtx.drawImage(currentCarImg, 0, 0, carDisplayWidth, carDisplayHeight);

                } else {
                    // 白（monochrome）の場合：
                    // すでに白化処理済みなので、何もしなければ「真っ白な車」になる。
                    // そのままでOK。
                }

                // 5. 最後にメインキャンバスへ描画
                ctx.drawImage(window.carTintCanvas, carX, carY, carDisplayWidth, carDisplayHeight);
                ctx.restore();
                return;
            }
        }

        let woOverlay = null; // キャッシュ用

        // --- 更新ルーチン ---
        function update(dt) {
            // OPENING: オートラン（字幕用）
            if (gameState === 'opening') {
                speed = 400; // 30km/h程度で走行するように変更 
                position = (position + speed * dt) % (segments.length * segmentLength);

                // 字幕更新
                const elapsed = (Date.now() - gameStartTime) / 1000; // 秒
                // duration(35s)に合わせて字幕を出す
                const totalDuration = 35;
                const timeProg = Math.min(1.0, elapsed / totalDuration);

                let textJP = "";
                let textEN = "";

                if (elapsed < 1.0) {
                    // 開始1秒間は何も表示しない
                    textEN = "";
                    textJP = "";
                } else if (elapsed < 4.0) {
                    textEN = "Textiles carry stories within them.";
                    textJP = "繊維には、物語があります。";
                } else if (elapsed < 11.0) {
                    textEN = "Some gain character through years of use,<br>while others are discarded, never knowing a human touch.";
                    textJP = "何度も使われ、味わいを帯びた繊維。<br>誰にも触れられず、役目を果たせないまま廃棄される繊維。";
                } else if (elapsed < 15.0) {
                    textEN = "Inside every car, textiles live in silence.";
                    textJP = "車の中にも、ひっそりと息づく繊維があります。";
                } else if (elapsed < 20.0) {
                    textEN = "Seats, floors, filters, and cushions.";
                    textJP = "シート、フロア、フィルター、クッション。";
                } else if (elapsed < 29.0) {
                    textEN = "We gently unearth their hidden narratives<br>to weave new possibilities for the future.";
                    textJP = "私たちは、その物語を丁寧にすくい上げ、<br>繊維が持つ新たな可能性を紡いでいきます。";
                } else {
                    textEN = "";
                    textJP = "";
                }

                if (textEN && textJP) {
                    caption.innerHTML = `<span style="font-family: 'DIN 2014', 'Barlow', sans-serif; font-size: 0.9em;">${textEN}</span><br><span style="font-family: 'Noto Sans JP', sans-serif; font-size: 0.8em; opacity: 0.9;">${textJP}</span>`;
                    caption.style.opacity = 1;
                } else {
                    caption.style.opacity = 0;
                }

                // Openingでもメーターを動かす
                const actualSpeed = speed * speedMultiplier * 1.8; // 18000 * 0.006 * 1.8 = 194.4km/h
                const jitter = (Math.random() - 0.5) * 0.2; // ジッターを少し控えめに
                if (speedValue) speedValue.textContent = (actualSpeed + jitter).toFixed(1);

                return;
            }

            // READY: 減速停止
            if (gameState === 'ready') {
                caption.style.opacity = 0; // 字幕消す
                // より自然なブレーキ：一定の減速度で0に向かう
                if (speed > 0) {
                    speed -= 8; // 毎フレーム一定量減速
                    if (speed < 0) speed = 0;
                }
                position = (position + speed * dt) % (segments.length * segmentLength);

                // メーターを徐々に0にする
                const actualSpeed = speed * speedMultiplier * 1.8;
                if (speedValue) speedValue.textContent = actualSpeed.toFixed(1);
                return;
            }

            // PLAYING: 通常制御
            if (gameState !== 'playing') return;

            // --- データ計測 ---
            playData.totalDistance += speed * speedMultiplier;
            const currentSteer = isMobile ? touchSteerDir : (keyLeft ? -1 : (keyRight ? 1 : 0));

            // ステアリング計測の改善（ヒステリシス付き）
            const STEER_THRESHOLD = 0.2;

            // 意図的な方向転換の検知
            if (Math.abs(currentSteer) > STEER_THRESHOLD) {
                if (playData.lastSignificantDir !== 0 && Math.sign(currentSteer) !== Math.sign(playData.lastSignificantDir)) {
                    playData.steeringFlipCount++;
                    playData.lastSignificantDir = currentSteer;
                } else if (playData.lastSignificantDir === 0) {
                    playData.lastSignificantDir = currentSteer;
                }
            }

            // 迷い度（Wandering）の計測: 蛇行の総量
            if (speed > 100) {
                steeringInputSum += Math.abs(currentSteer);
            }

            lastSteerDir = currentSteer;
            if (Math.random() < 0.05) playData.speedHistory.push(speed);

            // 字幕更新（PLAYING中は非表示）
            caption.style.opacity = 0;

            // 速度UI更新
            const actualSpeed = speed * speedMultiplier * 1.8;
            speedValue.textContent = actualSpeed.toFixed(1);

            const elapsed = Date.now() - gameStartTime;

            // 残り3秒からホワイトアウトとフェードアウト
            const fadeStart = gameDuration - 2000;
            if (elapsed > fadeStart) {
                const fadeProg = Math.min(1.0, (elapsed - fadeStart) / 2000);

                // 1. ホワイトアウト (キャッシュ使用)
                if (!woOverlay) woOverlay = document.getElementById('whiteout-overlay');
                if (woOverlay) woOverlay.style.opacity = fadeProg;

                // 2. 音量フェードアウト
                if (window.bgm) window.bgm.volume = 0.5 * (1 - fadeProg);
                if (window.motor) window.motor.volume = 0.6 * (1 - fadeProg);
            }

            if (elapsed > gameDuration && !gameEnded) {
                endGame();
            }
        }

        let lastTime = 0;

        // --- メインループ ---
        function loop() {
            if (gameState === 'start') {
                lastTime = Date.now();
                requestAnimationFrame(loop);
                return;
            }

            const now = Date.now();
            // デルタタイム計算 (最大0.1秒でキャップして飛び飛び防ぐ)
            const dt = Math.min((now - lastTime) / 1000, 0.1);
            lastTime = now;

            // 共通更新処理
            update(dt);

            if (gameState === 'playing') {
                const elapsed = Date.now() - gameStartTime;
                if (elapsed > gameDuration && !gameEnded) {
                    endGame();
                    requestAnimationFrame(loop);
                    return;
                }

                // グリッチエフェクト（衝突時）
                if (window.glitchIntensity > 0) {
                    const intensity = window.glitchIntensity;

                    // 1. 画面のずれ（RGB分離風）
                    ctx.save();
                    ctx.globalCompositeOperation = 'screen';
                    ctx.fillStyle = `rgba(255, 255, 255, ${0.5 * intensity})`;
                    ctx.fillRect(0, 0, width, height);

                    for (let i = 0; i < 5 + 10 * intensity; i++) {
                        const h = Math.random() * 50 * intensity;
                        const y = Math.random() * height;
                        const dx = (Math.random() - 0.5) * 40 * intensity;
                        ctx.drawImage(canvas, 0, y, width, h, dx, y, width, h);
                    }
                    ctx.restore();

                    // 減衰
                    window.glitchIntensity *= 0.85;
                    if (window.glitchIntensity < 0.01) window.glitchIntensity = 0;
                }

                const dtScale = dt * 60; // 60FPS基準のスケール係数

                if (isMobile) {
                    // Mobile加速ブースト削除（基本速度を上げたため）
                    speed += accel * dtScale;
                } else {
                    if (keyFaster) speed += accel * dtScale; else speed += decel * dtScale;
                }

                const currentSeg = segments[Math.floor(position / segmentLength) % segments.length];
                const curveForce = currentSeg.curve * (speed / maxSpeed) * 0.000005 * dtScale;
                playerX += curveForce;

                const steerSpeed = isMobile ? 0.04 : 0.015; // ハンドル感度 (1.5倍)
                let steerDir = 0;
                if (isMobile) {
                    steerDir = touchSteerDir;
                } else {
                    steerDir = (keyRight ? 1 : 0) + (keyLeft ? -1 : 0);
                }
                if (steerDir !== 0) {
                    playerX += steerDir * steerSpeed * dtScale;
                }

                // データ収集
                lastPlayerX = playerX;

                // コースアウト判定
                if ((playerX < -1 || playerX > 1) && speed > offRoadLimit) {
                    speed += offRoadDecel * dtScale;
                    playData.collisionCount += 0.05 * dtScale;
                }

                playerX = Math.max(-2, Math.min(2, playerX));
                speed = Math.max(0, Math.min(maxSpeed, speed));

                // speedMultiplierは定数(0.006)なので、これにdtScaleを掛けることで移動量を実時間依存にする
                position += speed * speedMultiplier * dtScale;
                while (position >= totalSegments * segmentLength) position -= totalSegments * segmentLength;
                while (position < 0) position += totalSegments * segmentLength;
            }

            // 描画 (Playing, Opening, Ready)
            if (gameState === 'playing' || gameState === 'opening' || gameState === 'ready') {
                render();
            }

            if (!gameEnded) {
                requestAnimationFrame(loop);
            }
        }

        // --- 終了処理 ---
        function endGame() {
            if (gameEnded) return;
            gameEnded = true;
            gameState = 'result';

            if (window.bgm) { window.bgm.pause(); window.bgm.currentTime = 0; }
            if (window.motor) { window.motor.pause(); window.motor.currentTime = 0; }
            if (window.narration) { window.narration.pause(); }

            document.getElementById('ui-layer').style.display = 'none';
            document.getElementById('speedometer').style.display = 'none';
            document.getElementById('gameCanvas').style.display = 'none';
            document.getElementById('scanlines').style.display = 'none';

            // ホワイトアウト解除
            const wo = document.getElementById('whiteout-overlay');
            if (wo) {
                wo.style.opacity = '0';
                setTimeout(() => wo.style.display = 'none', 500); // フェード後に消す
            }

            const resScreen = document.getElementById('result-screen');
            resScreen.classList.add('active');

            // パラメータ解析
            // パラメータ解析
            // ---------------------------------------------------
            // 1. 色の集計と決定 (Color Logic)
            // ---------------------------------------------------
            const sortedColors = Object.entries(playData.itemCounts)
                .sort((a, b) => b[1] - a[1]) // 回数が多い順
                .filter(entry => entry[1] > 0)
                .map(entry => entry[0]);

            // メインカラー: 最も多く取った色（なければ最後に取った色、それもなければモノクロ）
            // ※「最後に取った色」より「多く取った色」の方が「執着」を表すため
            let mainColor = sortedColors[0] || lastCollectedColor || 'monochrome';

            // VIP用サブカラー
            let subColor = sortedColors[1] || mainColor;

            // 結果画面での表示用に保存
            const selectedPalette = mainColor;

            // ---------------------------------------------------
            // 2. スコア算出 (Score Logic)
            // ---------------------------------------------------

            // G (Greed): 執着度 (アイテム取得数)
            // 0〜10個で判定。多すぎると真っ黒になるのでMAX10程度で正規化
            const totalItems = Object.values(playData.itemCounts).reduce((a, b) => a + b, 0);
            const greedScore = Math.min(1.0, totalItems / 10);

            // S (Steer): 迷い度 (切り返し回数重視)
            // Flip回数: 意図的な切り返し。20回以上で「迷い」とみなすよう緩和
            const flipScore = Math.min(1.0, playData.steeringFlipCount / 24);
            // Wander: 入力総量。あくまで補助的（カーブ対応分も含むため）
            const avgSteeringInput = steeringInputSum / (playData.speedHistory.length || 1);
            const wanderScore = Math.min(1.0, avgSteeringInput * 2.0);

            // 迷い度 = 切り返し(80%) + 蛇行量(20%)
            const steerScore = (flipScore * 0.9) + (wanderScore * 0.1);

            // R (Risk): リスク許容度 (衝突数)
            // 0回=0.0, 5回以上=1.0
            const crashScore = Math.min(1.0, playData.collisionCount * 0.2);

            // Speed: 平均速度 (参考値として算出するが、生成パラメータへの影響は下げる)
            const avgSpeed = playData.speedHistory.reduce((a, b) => a + b, 0) / (playData.speedHistory.length || 1);
            // const speedScore = Math.min(1.0, avgSpeed / maxSpeed); // 廃止

            // ---------------------------------------------------
            // 3. グラフィック生成パラメータ (Generation Params)
            // ---------------------------------------------------
            const seed = Math.random();

            // Amp (振幅): S値（迷い）がそのまま波の大きさに
            const warpAmpBase = 0.05 + steerScore * 0.5; // 0.05 ~ 0.55
            const warpAmpRand = (seed * 0.2) - 0.1;
            const finalWarpAmp = Math.max(0.02, warpAmpBase + warpAmpRand);

            // Freq (周波数): S値が高い＝細かく震える
            const warpFreqBase = 0.1 + steerScore * 0.6;
            const warpFreqRand = (Math.random() * 0.4) - 0.2;
            const finalWarpFreq = Math.max(0.1, warpFreqBase + warpFreqRand);

            // Density (密度): Greed（執着）が高いほど密度が高くなる
            // 欲深い＝目が詰まっている
            const densityBase = 0.2 + greedScore * 0.6; // 0.2 ~ 0.8
            const finalDensity = Math.min(0.9, densityBase + (Math.random() * 0.1));

            // Style: R値（リスク）とS値（迷い）で決定
            let styleType = 'classic';
            if (crashScore > 0.5) {
                styleType = 'glitch'; // 傷だらけ
            } else if (steerScore > 0.5) {
                styleType = 'organic'; // 迷いが多い＝有機的
            } else {
                // ランダムで少し混ぜる
                if (Math.random() < 0.3) styleType = 'organic';
            }

            const genParams = {
                paletteId: mainColor,
                warpAmp: finalWarpAmp,
                warpFreq: finalWarpFreq,
                density: finalDensity,
                noise: crashScore * 0.6 + (styleType === 'glitch' ? 0.3 : 0),
                style: styleType
            };

            // ---------------------------------------------------
            // 4. 診断用データ (Diagnosis Data)
            // ---------------------------------------------------
            const diagnosisParams = {
                steeringHesitation: playData.steeringFlipCount,
                riskTolerance: playData.collisionCount,
                itemGreediness: {
                    total: totalItems,
                    details: playData.itemCounts
                },
                colorPreference: mainColor, // ここもTop1を使用
                baseMetrics: {
                    avgSpeed: avgSpeed,
                    steerScore: steerScore,
                    crashScore: crashScore
                }
            };

            // 相性診断の準備
            if (window.isVip) {
                diagnosisParams.compatibility = {
                    partnerWarp: genParams,
                    myWeft: genParams
                };
            } else if (window.isWeftMode && window.warpDataFromUrl) {
                diagnosisParams.compatibility = {
                    partnerWarp: window.warpDataFromUrl,
                    myWeft: genParams
                };
            }

            console.log("Diagnosis Data:", diagnosisParams);

            // ---------------------------------------------------
            // 5. テキスタイル生成実行
            // ---------------------------------------------------
            let dataUrl;
            if (window.isVip) {
                // VIP: Top1色 x Top2色
                console.log(`VIP Weaving: ${mainColor} x ${subColor}`);

                // 経糸 (Main)
                const warpP = JSON.parse(JSON.stringify(genParams));
                warpP.paletteId = mainColor;

                // 緯糸 (Sub)
                const weftP = JSON.parse(JSON.stringify(genParams));
                weftP.paletteId = subColor;

                dataUrl = generateTextile(warpP, weftP);
            } else if (window.isWeftMode && window.warpDataFromUrl) {
                dataUrl = generateTextile(window.warpDataFromUrl, genParams);
            } else {
                dataUrl = generateTextile(genParams, null);
            }

            const imgEl = document.getElementById('material-image');
            imgEl.src = dataUrl;
            imgEl.onload = () => {
                document.getElementById('loading-text').style.display = 'none';
                imgEl.style.display = 'block';

                // 統合レポート生成 (New)
                generateAnalysisReport(diagnosisParams, result);
                document.getElementById('analysis-report').style.display = 'block';
                document.getElementById('material-id').style.display = 'block';
                if (!window.isVip) {
                    document.getElementById('reserve-btn').style.display = 'block';
                    document.getElementById('calendar-btn').style.display = 'block';
                } else {
                    document.getElementById('calendar-btn').style.display = 'none';
                }

                // コラボエリア表示制御
                const collabSection = document.getElementById('collab-section');
                collabSection.style.display = 'block';

                // 全てのセクションを一旦隠す
                document.getElementById('warp-mode-actions').style.display = 'none';
                document.getElementById('weft-mode-result').style.display = 'none';
                document.getElementById('vip-mode-result').style.display = 'none';

                if (window.isVip) {
                    // C. VIPモード
                    document.getElementById('vip-mode-result').style.display = 'block';

                    // ヘッダータイトルの更新 (セレクタ修正)
                    const titleEl = document.querySelector('#result-screen .header');
                    if (titleEl) titleEl.innerHTML = `OFFICIAL TICKET`;

                    // チケットホルダー情報の追加
                    const holderArea = document.getElementById('vip-ticket-holder');
                    const nameEl = document.getElementById('vip-holder-name');
                    if (holderArea && nameEl && window.vipData) {
                        nameEl.innerText = window.vipData.name;
                        holderArea.style.display = 'block';
                    }
                } else if (window.isWeftMode && window.warpDataFromUrl) {
                    // B. 緯糸モード (コラボ完了)
                    document.getElementById('weft-mode-result').style.display = 'block';
                } else {
                    // A. 経糸モード (一般客 → 招待へ)
                    document.getElementById('warp-mode-actions').style.display = 'block';
                }
            };

            const date = new Date();
            const idStr = `MAT-${date.getFullYear()}${(date.getMonth() + 1).toString().padStart(2, '0')}-${Math.floor(Math.random() * 9999)}`;
            document.getElementById('material-id').innerText = idStr;

            // --- 繊維タイプ診断ロジック (Ver 2.0) ---
            const steer = playData.steeringFlipCount;
            const risk = playData.collisionCount;
            const greed = Object.values(playData.itemCounts).reduce((a, b) => a + b, 0);

            let result = { id: 15, nameEn: "UNKNOWN MATERIAL", nameJp: "未解析のマテリアル", desc: "解析不能。既存の繊維データに該当しない、特異点（シンギュラリティ）。" };

            // 1. 特殊枠 (優先度高)
            if (steer < 7 && risk < 1.1 && greed < 4) {
                result = { id: 1, nameEn: "GHOST ORGANZA", nameJp: "幽霊のオーガンジー", desc: "存在感が希薄で、透明に近い。世界に干渉することを拒んだ、儚い繊維。" };
            } else if (risk < 1.1 && greed >= 9) {
                result = { id: 2, nameEn: "ARMORED KEVLAR", nameJp: "武装するケブラー", desc: "圧倒的な防御力と貪欲さ。傷一つ負わずに全てを手に入れる、最強の合成繊維。" };
            } else if (risk >= 8) {
                result = { id: 3, nameEn: "BURNT VINYL", nameJp: "焦げたビニール", desc: "摩擦熱で溶け出し、異臭を放つ。痛みを燃料にして走る、危険な物質。" };
            } else if (steer >= 40) {
                result = { id: 4, nameEn: "NEURAL FIBER", nameJp: "ニューラル・ファイバー", desc: "複雑に絡み合う思考の迷路。繊細すぎて、誰にも解くことができない脳内繊維。" };
            }
            // 2. 通常枠
            else {
                if (risk < 1.1) { // Risk: Low
                    if (steer < 7) result = { id: 5, nameEn: "PURE SILK", nameJp: "純白のシルク", desc: "迷いのない一直線の美しさ。高貴だが、汚れを知らないため染まりやすい。" };
                    else if (greed >= 9) result = { id: 6, nameEn: "HOLOGRAPHIC FILM", nameJp: "偏光フィルム", desc: "揺れ動くたびに色を変える。多面的で掴みどころがない、現代的な輝き。" };
                    else result = { id: 7, nameEn: "GLASS FIBER", nameJp: "グラスファイバー", desc: "繊細で折れやすいが、鋭い透過性を持つ。触れる者を傷つけるガラスの糸。" };
                } else if (risk < 5) { // Risk: Mid (1.1 - 4.9)
                    if (steer < 7) {
                        if (greed >= 9) result = { id: 9, nameEn: "CLASSIC TWEED", nameJp: "伝統的なツイード", desc: "多くの色（欲望）を整然と織り込んだ、知的でトラディショナルな厚み。" };
                        else result = { id: 8, nameEn: "HEAVY CANVAS", nameJp: "頑丈な帆布", desc: "質実剛健。面白みには欠けるが、最も信頼でき、何にでもなれる素材。" };
                    } else {
                        if (greed >= 9) result = { id: 11, nameEn: "ACTIVE MESH", nameJp: "躍動するメッシュ", desc: "通気性と伸縮性が抜群。じっとしていられない、エネルギーの塊。" };
                        else result = { id: 10, nameEn: "MEDICAL GAUZE", nameJp: "癒やしのガーゼ", desc: "柔らかく、優しく包み込む。迷い傷ついた経験が、他者への優しさになる。" };
                    }
                } else { // Risk: High (5+)
                    if (steer < 7) result = { id: 12, nameEn: "VINTAGE DENIM", nameJp: "ヴィンテージデニム", desc: "傷つくほどに味が出る。不器用な生き方がそのままテクスチャになった、不朽の定番。" };
                    else if (greed >= 9) result = { id: 13, nameEn: "GLITCH NYLON", nameJp: "グリッチナイロン", desc: "ノイズと蛍光色が混ざり合う。カオスを愛する、デジタル世代のパンク素材。" };
                    else result = { id: 14, nameEn: "BORO PATCHWORK", nameJp: "継ぎ接ぎのボロ", desc: "拾い集めた断片を縫い合わせた記憶の布。貧しいのではなく、歴史が深い。" };
                }
            }

            // 表示更新
            // const styleName = genParams.style.toUpperCase();
            // const dens = Math.floor(genParams.density * 100);

            // 旧診断表示ロジック削除 (Combined Reportに統合済み)

            // genParamsをグローバルに保存（招待リンク生成用）
            window.currentWarpData = genParams;
            window.diagnosisResults = result; // 結果をグローバル保存
            window.diagnosisParams = diagnosisParams; // パラメータ詳細も保存

            // --- ローカルストレージに保存 (Persistence) ---
            const finalKey = getStorageKey();

            let currentMode = 'warp';
            if (window.isVip) currentMode = 'vip';
            else if (window.isWeftMode) currentMode = 'weft';

            const saveData = {
                genParams: genParams,
                diagnosisResults: result,
                diagnosisParams: diagnosisParams, // 詳細レポート用に追加
                vipData: window.vipData,
                vipColors: window.isVip ? { main: mainColor, sub: subColor } : null,
                playMode: currentMode, // 復元判定用モード
                timestamp: Date.now()
            };
            localStorage.setItem(finalKey, JSON.stringify(saveData));
        }



        // --- 診断ロジック関数 (Extracted) ---
        function calculateDiagnosis(data, color) {
            const steer = data.steeringFlipCount;
            const risk = data.collisionCount;
            const greed = Object.values(data.itemCounts).reduce((a, b) => a + b, 0);

            let result = { id: 15, nameEn: "UNKNOWN MATERIAL", nameJp: "未解析のマテリアル", desc: "解析不能。既存の繊維データに該当しない、特異点（シンギュラリティ）。" };

            // 1. 特殊枠 (優先度高)
            if (steer < 7 && risk < 1.1 && greed < 4) {
                result = { id: 1, nameEn: "GHOST ORGANZA", nameJp: "幽霊のオーガンジー", desc: "存在感が希薄で、透明に近い。世界に干渉することを拒んだ、儚い繊維。" };
            } else if (risk < 1.1 && greed >= 9) {
                result = { id: 2, nameEn: "ARMORED KEVLAR", nameJp: "武装するケブラー", desc: "圧倒的な防御力と貪欲さ。傷一つ負わずに全てを手に入れる、最強の合成繊維。" };
            } else if (risk >= 8) {
                result = { id: 3, nameEn: "BURNT VINYL", nameJp: "焦げたビニール", desc: "摩擦熱で溶け出し、異臭を放つ。痛みを燃料にして走る、危険な物質。" };
            } else if (steer >= 20) {
                result = { id: 4, nameEn: "NEURAL FIBER", nameJp: "ニューラル・ファイバー", desc: "複雑に絡み合う思考の迷路。繊細すぎて、誰にも解くことができない脳内繊維。" };
            }
            // 2. 通常枠
            else {
                if (risk < 1.1) { // Risk: Low
                    if (steer < 7) result = { id: 5, nameEn: "PURE SILK", nameJp: "純白のシルク", desc: "迷いのない一直線の美しさ。高貴だが、汚れを知らないため染まりやすい。" };
                    else if (greed >= 9) result = { id: 6, nameEn: "HOLOGRAPHIC FILM", nameJp: "偏光フィルム", desc: "揺れ動くたびに色を変える。多面的で掴みどころがない、現代的な輝き。" };
                    else result = { id: 7, nameEn: "GLASS FIBER", nameJp: "グラスファイバー", desc: "繊細で折れやすいが、鋭い透過性を持つ。触れる者を傷つけるガラスの糸。" };
                } else if (risk < 5) { // Risk: Mid (1.1 - 4.9)
                    if (steer < 7) {
                        if (greed >= 9) result = { id: 9, nameEn: "CLASSIC TWEED", nameJp: "伝統的なツイード", desc: "多くの色（欲望）を整然と織り込んだ、知的でトラディショナルな厚み。" };
                        else result = { id: 8, nameEn: "HEAVY CANVAS", nameJp: "頑丈な帆布", desc: "質実剛健。面白みには欠けるが、最も信頼でき、何にでもなれる素材。" };
                    } else {
                        if (greed >= 9) result = { id: 11, nameEn: "ACTIVE MESH", nameJp: "躍動するメッシュ", desc: "通気性と伸縮性が抜群。じっとしていられない、エネルギーの塊。" };
                        else result = { id: 10, nameEn: "MEDICAL GAUZE", nameJp: "癒やしのガーゼ", desc: "柔らかく、優しく包み込む。迷い傷ついた経験が、他者への優しさになる。" };
                    }
                } else { // Risk: High (5+)
                    if (steer < 7) result = { id: 12, nameEn: "VINTAGE DENIM", nameJp: "ヴィンテージデニム", desc: "傷つくほどに味が出る。不器用な生き方がそのままテクスチャになった、不朽の定番。" };
                    else if (greed >= 9) result = { id: 13, nameEn: "GLITCH NYLON", nameJp: "グリッチナイロン", desc: "ノイズと蛍光色が混ざり合う。カオスを愛する、デジタル世代のパンク素材。" };
                    else result = { id: 14, nameEn: "BORO PATCHWORK", nameJp: "継ぎ接ぎのボロ", desc: "拾い集めた断片を縫い合わせた記憶の布。貧しいのではなく、歴史が深い。" };
                }
            }
            return result;
        }



        // --- レポート生成ロジック (Integrated Text Report) ---
        function generateAnalysisReport(params, resultData) {
            const reportDiv = document.getElementById('analysis-report');
            if (!reportDiv) return;

            const sScore = params.baseMetrics.steerScore;
            const rScore = params.baseMetrics.crashScore;
            const gTotal = params.itemGreediness.total;
            const mainColor = params.colorPreference.toUpperCase();

            // 文脈判定 (Context) - シンプルに役割のみ定義
            let subject = "経糸（タテイト）";
            let product = "マテリアル";
            let compatibilityText = "";

            if (window.isVip) {
                subject = "布（テキスタイル）";
                product = "この一枚";
                compatibilityText = `YOUR OWN WEAVING`;
            } else if (window.isWeftMode && window.warpDataFromUrl) {
                subject = "緯糸（ヨコイト）";
                product = "コラボレーション";
                compatibilityText = `COLLABORATION: HOST & YOU`;
            } else {
                // 通常モード（経糸のみ）
                subject = "経糸（タテイト）";
                product = "素材";
            }

            // 1. Steering & Speed (Shape)
            let shapeText = "";
            const flipCount = params.steeringHesitation;
            if (sScore > 0.6) {
                shapeText = `頻繁な切り返し（Flip: ${flipCount}回）が記録されました。その心の揺れが、${subject}に激しい波打ちを与え、複雑に歪んだ形状を生み出しています。`;
            } else if (sScore > 0.25) {
                shapeText = `時折見せたハンドルの揺らぎ（Flip: ${flipCount}回）が、${subject}に有機的で柔らかなウェーブを描き出しました。`;
            } else {
                shapeText = `迷いのないハンドル操作（Flip: ${flipCount}回）で、スムーズに走り抜けました。そのため、${subject}は美しく真っ直ぐに伸び、凛とした表情を持っています。`;
            }

            // 2. Risk (Texture)
            let textureText = "";
            const collisionCount = Math.floor(params.riskTolerance);
            if (rScore > 0.5) {
                textureText = `度重なる衝突（Collision: ${collisionCount}回）を恐れぬ走りが、全体にノイズとグリッチ（傷跡）を刻み込みました。`;
            } else if (rScore > 0.1) {
                textureText = `攻めの走りによる接触（Collision: ${collisionCount}回）が、適度な荒々しさを質感に加えています。`;
            } else {
                textureText = `衝突を避けた安全運転により、傷のない滑らかな質感に仕上がっています。`;
            }

            // 3. Greed & Color (Density & Color)
            let densityText = "";
            let colorText = "";

            // 色の名称変換 (簡易)
            const colorMap = {
                'RED': '赤', 'BLUE': '青', 'GREEN': '緑',
                'ORANGE': 'オレンジ', 'PURPLE': '紫', 'MONOCHROME': '無彩色'
            };
            const colName = colorMap[mainColor] || mainColor;

            if (gTotal >= 8) {
                densityText = `多くの欲望（Items: ${gTotal}個）を求めた結果、目が詰まった重厚で高密度な仕上がりになりました。`;
                colorText = `特に「${colName}」への執着が強く、その色が全体を支配しています。`;
            } else if (gTotal >= 4) {
                densityText = `適度な収集欲（Items: ${gTotal}個）により、バランスの取れた密度の${product}になっています。`;
                colorText = `「${colName}」を基調とした、落ち着きのある配色です。`;
            } else {
                densityText = `収集を抑えた（Items: ${gTotal}個）ことで、非常に軽やかで透け感のある仕上がりになりました。`;
                colorText = `「${colName}」が静かに主張する、ミニマルな構成です。`;
            }

            // HTML構築
            const html = `
                <div class="report-section">
                    <div class="report-title">DRIVING RESULT</div>
                    <div class="report-text">
                        ${shapeText}
                        ${textureText}
                        ${densityText}
                        ${colorText}
                    </div>
                </div>

                <div class="report-section" style="border-bottom: none;">
                    <div class="report-title">MATERIAL DIAGNOSIS</div>
                    <div class="report-text">
                        繊維で言うなら、このマテリアルでしょう。
                    </div>
                    
                    <div class="diagnosis-name-en">
                        ${resultData.nameEn}
                    </div>
                    <div class="diagnosis-name-jp">
                        ${resultData.nameJp}
                    </div>
                    <div class="diagnosis-desc">
                        ${resultData.desc}
                    </div>
                    
                    <div style="margin-top: 25px; font-size: 10px; color: #ccc; font-family: 'DIN 2014';">
                        S:${(params.baseMetrics.steerScore).toFixed(2)} / R:${(params.baseMetrics.crashScore).toFixed(2)} / G:${gTotal}
                    </div>
                </div>
            `;

            reportDiv.innerHTML = html;
            reportDiv.style.display = 'block';
        }

        // --- テキスタイル生成エンジン ---
        const textileEngine = {
            palettes: {
                monochrome: { bg: '#ffffff', warp: '#1a1a1a', weft: '#1a1a1a' },
                red: { bg: '#ffffff', warp: '#e60012', weft: '#e60012' },
                blue: { bg: '#ffffff', warp: '#0066cc', weft: '#0066cc' },
                green: { bg: '#ffffff', warp: '#009944', weft: '#009944' },
                orange: { bg: '#ffffff', warp: '#ff6600', weft: '#ff6600' },
                purple: { bg: '#ffffff', warp: '#6b0099', weft: '#6b0099' }
            },
            warpSeed: 1,
            weftSeed: 1,
            warpRnd: function () { this.warpSeed = (this.warpSeed * 9301 + 49297) % 233280; return this.warpSeed / 233280; },
            weftRnd: function () { this.weftSeed = (this.weftSeed * 7901 + 31337) % 233280; return this.weftSeed / 233280; },
            hexToRgba: function (hex, alpha) {
                const r = parseInt(hex.slice(1, 3), 16);
                const g = parseInt(hex.slice(3, 5), 16);
                const b = parseInt(hex.slice(5, 7), 16);
                return `rgba(${r}, ${g}, ${b}, ${alpha})`;
            }
        };

        function generateTextile(warpParams, weftParams = null) {
            const tCanvas = document.getElementById('textileCanvas');
            const tCtx = tCanvas.getContext('2d');
            const W = tCanvas.width;
            const H = tCanvas.height;

            textileEngine.warpSeed = Date.now();
            textileEngine.weftSeed = Date.now() + 99999;

            // 経糸のパレット
            const warpPal = textileEngine.palettes[warpParams.paletteId] || textileEngine.palettes.monochrome;
            // 緯糸のパレット（指定があれば）
            const weftPal = weftParams ? (textileEngine.palettes[weftParams.paletteId] || textileEngine.palettes.monochrome) : warpPal;

            tCtx.fillStyle = warpPal.bg;
            tCtx.fillRect(0, 0, W, H);

            const warpSpacing = 20 + (1 - warpParams.density) * 70;
            const warpAmp = warpParams.warpAmp * 60;
            const warpFreq = 0.002 + warpParams.warpFreq * 0.02;
            const lineW = 1.0 + 0.3 * 25;
            const warpNoise = warpParams.noise;
            const warpStyle = warpParams.style;
            const alpha = 1.0;

            tCtx.lineCap = 'round';
            tCtx.lineJoin = 'round';

            // WARP（経糸）描画
            tCtx.strokeStyle = textileEngine.hexToRgba(warpPal.warp, alpha);
            tCtx.lineWidth = lineW;
            for (let x = warpSpacing / 2; x < W; x += warpSpacing) {
                if (textileEngine.warpRnd() < warpNoise * 0.15) continue;
                tCtx.beginPath();
                const phase = textileEngine.warpRnd() * Math.PI * 2;
                const localAmp = warpAmp * (0.6 + textileEngine.warpRnd() * 0.4);
                const localFreq = warpFreq * (0.7 + textileEngine.warpRnd() * 0.6);
                for (let y = 0; y <= H; y += 4) {
                    let wave = Math.sin(y * localFreq + phase) * localAmp;
                    if (warpNoise > 0) wave += (textileEngine.warpRnd() - 0.5) * warpNoise * 30;
                    if (warpStyle === 'organic') wave += Math.sin(y * 0.005 + x * 0.002) * 40;
                    else if (warpStyle === 'glitch') if (textileEngine.warpRnd() < 0.02) wave += (textileEngine.warpRnd() - 0.5) * 200;
                    const px = x + wave;
                    y === 0 ? tCtx.moveTo(px, y) : tCtx.lineTo(px, y);
                }
                tCtx.stroke();
            }

            // WEFT（緯糸）描画 - weftParamsが指定された場合のみ
            if (weftParams) {
                const weftSpacing = 20 + (1 - weftParams.density) * 70;
                const weftAmp = weftParams.warpAmp * 60;
                const weftFreq = 0.002 + weftParams.warpFreq * 0.02;
                const weftNoise = weftParams.noise;
                const weftStyle = weftParams.style;

                tCtx.strokeStyle = textileEngine.hexToRgba(weftPal.weft, alpha);
                tCtx.lineWidth = lineW * 0.85;
                for (let y = weftSpacing / 2; y < H; y += weftSpacing) {
                    if (textileEngine.weftRnd() < weftNoise * 0.2) continue;
                    tCtx.beginPath();
                    const phase = textileEngine.weftRnd() * Math.PI * 2;
                    const localAmp = weftAmp * (0.6 + textileEngine.weftRnd() * 0.4);
                    const localFreq = weftFreq * (0.7 + textileEngine.weftRnd() * 0.6);
                    for (let x = 0; x <= W; x += 4) {
                        let wave = Math.sin(x * localFreq + phase) * localAmp;
                        if (weftNoise > 0) wave += (textileEngine.weftRnd() - 0.5) * weftNoise * 30;
                        if (weftStyle === 'organic') wave += Math.cos(x * 0.005 + y * 0.002) * 30;
                        else if (weftStyle === 'glitch') if (textileEngine.weftRnd() < 0.02) wave += (textileEngine.weftRnd() - 0.5) * 160;
                        const py = y + wave;
                        x === 0 ? tCtx.moveTo(x, py) : tCtx.lineTo(x, py);
                    }
                    tCtx.stroke();
                }
            }

            const g = tCtx.createRadialGradient(W / 2, H / 2, H * 0.4, W / 2, H / 2, H * 0.9);
            g.addColorStop(0, 'rgba(255,255,255,0)');
            g.addColorStop(1, 'rgba(255,255,255,0.7)');
            tCtx.fillStyle = g;
            tCtx.fillRect(0, 0, W, H);

            return tCanvas.toDataURL('image/jpeg', 0.9);
        }

        // --- 共有機能 ---
        // --- 共有機能 (招待・コラボ完了) ---

        // --- URL圧縮ヘルパー ---
        function compressWarpData(data) {
            // キー短縮と数値丸め
            return {
                c: data.paletteId,
                a: parseFloat(data.warpAmp.toFixed(3)),
                f: parseFloat(data.warpFreq.toFixed(3)),
                d: parseFloat(data.density.toFixed(3)),
                n: parseFloat(data.noise.toFixed(3)),
                s: data.style
            };
        }

        function decompressWarpData(data) {
            // 短縮キーがある場合は復元、なければそのまま（互換性）
            if (data.c !== undefined) {
                return {
                    paletteId: data.c,
                    warpAmp: data.a,
                    warpFreq: data.f,
                    density: data.d,
                    noise: data.n,
                    style: data.s
                };
            }
            return data;
        }

        // 1. 招待リンク生成ヘルパー (Warpモード用)
        function getInviteUrl() {
            if (!window.currentWarpData) return window.location.href; // データなければトップへ

            // 圧縮してJSON化
            const compressed = compressWarpData(window.currentWarpData);
            const jsonStr = JSON.stringify(compressed);
            const base64 = btoa(jsonStr);

            const baseUrl = window.location.origin + window.location.pathname;
            return `${baseUrl}?warp=${base64}`;
        }

        // 2. Twitter 招待シェア (経糸モード完了時)
        function shareInviteToTwitter() {
            const url = getInviteUrl();
            const text = `未完成の布（経糸）を織りました。どなたか「緯糸」を織って、テキスタイルを完成させてくれませんか？\n#IndustrialRun #繊維産業研究報告会\n`;
            window.open(`https://twitter.com/intent/tweet?text=${encodeURIComponent(text)}&url=${encodeURIComponent(url)}`, '_blank');
        }

        // 3. LINE 招待シェア (経糸モード完了時)
        function shareInviteToLINE() {
            const url = getInviteUrl();
            const text = `未完成の布（経糸）を織りました。リンクを開いて「緯糸」を織るのを手伝ってください！\n繊維産業研究報告会 -車と繊維-`;
            window.open(`https://social-plugins.line.me/lineit/share?url=${encodeURIComponent(url)}&text=${encodeURIComponent(text)}`, '_blank');
        }

        // 3-2. LINE 報告 (緯糸モード完了時)
        function reportToHostLINE() {
            const text = `緯糸（ヨコイト）を織り上げました。二人の糸が交差する、世界に一枚の布が完成です！\n\n繊維産業研究報告会 -車と繊維-`;
            // 画像は送れないのでテキストのみシェア画面を開く
            window.open(`https://social-plugins.line.me/lineit/share?text=${encodeURIComponent(text)}`, '_blank');
        }

        // 3-3. VIP 出席シェア
        function shareAttendanceToTwitter() {
            const id = document.getElementById('material-id').innerText;
            const text = `繊維産業研究報告会 -車と繊維- に参加します。私だけの特別なテキスタイル・インビテーションが届きました。\n#IndustrialRun #20260228\nTicket ID: ${id}`;
            window.open(`https://twitter.com/intent/tweet?text=${encodeURIComponent(text)}&url=${encodeURIComponent(window.location.href)}`, '_blank');
        }

        // 4. 通常シェア (完了画像 or VIP)
        function shareToInstagram() {
            const imageUrl = document.getElementById('material-image').src;
            const a = document.createElement('a');
            a.href = imageUrl;
            a.download = 'industrial_run_textile.jpg';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }

        function shareToTwitter() {
            // 単純な結果シェア
            const text = `Industrial Run Material Generated: ${document.getElementById('material-id').innerText}\n#IndustrialRun`;
            window.open(`https://twitter.com/intent/tweet?text=${encodeURIComponent(text)}&url=${encodeURIComponent(window.location.href)}`, '_blank');
        }

        // 5. 手動コピー (Fallback)
        function copyInviteLink() {
            const url = getInviteUrl();
            const input = document.getElementById('invite-link-input');
            input.value = url;
            input.select();
            input.setSelectionRange(0, 99999);
            navigator.clipboard.writeText(url).then(() => {
                alert('Invite Link Copied!');
            }).catch(() => {
                alert('Copy failed. Please select and copy manually.');
            });
        }

        function goToReservation() {
            window.open('https://mautextileindustrylab.peatix.com/', '_blank');
        }

        function addToCalendar() {
            const baseUrl = "https://www.google.com/calendar/render?action=TEMPLATE";
            const title = "第一回 繊維産業研究報告会 -車と繊維-";
            const start = "20260228T170000";
            const end = "20260228T183000";
            const location = "イベントスペース MATERIAL（高円寺） 東京都杉並区高円寺南4-4-11";
            const details = "武蔵野美術大学 繊維産業研究会による初の研究成果発表の場です。トヨタ紡織「RE:TERRACE」からの素材提供を受け、自動車用繊維素材を用いたファッションショー、展示を行います。\n\n詳細：https://mautextileindustrylab.peatix.com/";

            const url = `${baseUrl}&text=${encodeURIComponent(title)}&dates=${start}/${end}&location=${encodeURIComponent(location)}&details=${encodeURIComponent(details)}`;
            window.open(url, '_blank');
        }

        // 古い関数（generateInviteLink）は廃止

        // Initialize Game
        init();

        // 6. リセット (RETRY)
        function resetUserData() {
            if (confirm("現在の結果データを削除して、最初からやり直しますか？\n(This will delete your woven textile data.)")) {
                const storageKey = getStorageKey();
                localStorage.removeItem(storageKey);
                window.location.reload();
            }
        }

        // 7. 結果画面復元 (Restore)
        function restoreResultScreen() {
            // ローディングを強制終了
            const loader = document.getElementById('loading-overlay');
            if (loader) {
                loader.style.opacity = '0';
                loader.style.display = 'none';
            }

            // ゲーム画面などを隠す
            gameState = 'ended'; // ゲームループへの影響を止める
            const startScreen = document.getElementById('start-screen');
            if (startScreen) startScreen.style.display = 'none';

            const mobileControls = document.getElementById('mobile-controls');
            if (mobileControls) mobileControls.style.display = 'none'; // 操作UIも隠す

            const uiLayer = document.getElementById('ui-layer');
            if (uiLayer) uiLayer.style.display = 'none'; // UIレイヤーを隠す (SYSTEM BOOTING含む)

            const speedMeter = document.getElementById('speedometer');
            if (speedMeter) speedMeter.style.display = 'none'; // スピードメーターも隠す

            document.getElementById('gameCanvas').style.display = 'none';
            const scanlines = document.getElementById('scanlines');
            if (scanlines) scanlines.style.display = 'block';

            // 初期キャプション (SYSTEM BOOTING...) を消す
            const caption = document.getElementById('caption');
            if (caption) caption.style.display = 'none';

            const resScreen = document.getElementById('result-screen');
            if (resScreen) {
                resScreen.style.display = 'flex';
                resScreen.style.opacity = '1';
            }

            // キャンバス描画
            setTimeout(() => {
                try {
                    const tCanvas = document.getElementById('textileCanvas');
                    let dataUrl = null;
                    if (tCanvas && window.genParams) {
                        if (window.vipData) {
                            // VIP復元: コアロジック再構築
                            if (!window.genParams) {
                                console.error("Missing genParams for VIP restoration");
                                throw new Error("保存データが不完全です (genParams missing)");
                            }

                            // vipColorsがあればそれを使う、なければgenParamsから推測、あるいはデフォルト
                            const mainColor = (window.vipColors && window.vipColors.main) ||
                                (window.vipData && window.vipData.color) ||
                                (window.genParams && window.genParams.paletteId) ||
                                'MONOCHROME';

                            const subColor = (window.vipColors && window.vipColors.sub) ||
                                (window.vipData && window.vipData.subColor) ||
                                mainColor;

                            // 経糸 (Main)
                            const warpP = JSON.parse(JSON.stringify(window.genParams));
                            warpP.paletteId = mainColor;

                            // 緯糸 (Sub)
                            const weftP = JSON.parse(JSON.stringify(window.genParams));
                            weftP.paletteId = subColor;

                            dataUrl = generateTextile(warpP, weftP);
                        } else if (window.isWeftMode && window.warpDataFromUrl) {
                            // コラボ復元: URL由来の経糸 + 自分の緯糸
                            dataUrl = generateTextile(window.warpDataFromUrl, window.genParams);
                        } else {
                            // 通常: 経糸のみ
                            dataUrl = generateTextile(window.genParams);
                        }
                    }

                    // 画像表示
                    const imgEl = document.getElementById('material-image');
                    if (imgEl && dataUrl) {
                        imgEl.src = dataUrl;
                        imgEl.style.display = 'block';
                    }

                    // ローディングテキスト非表示
                    const loadTxt = document.getElementById('loading-text');
                    if (loadTxt) loadTxt.style.display = 'none';

                    // マテリアルID表示
                    const idEl = document.getElementById('material-id');
                    if (idEl) idEl.style.display = 'block';

                    // 統合レポート生成 (New) - diagnosisParamsがある場合のみ
                    if (window.diagnosisParams && window.diagnosisResults) {
                        try {
                            generateAnalysisReport(window.diagnosisParams, window.diagnosisResults);
                            const repDiv = document.getElementById('analysis-report');
                            if (repDiv) repDiv.style.display = 'block';
                        } catch (e) {
                            console.error("Analysis Report Generation Failed:", e);
                            // レポート生成失敗時は非表示のままにする（エラーで全体を止めない）
                        }
                    }

                    // テキスト反映
                    const r = window.diagnosisResults;
                    if (r) {
                        const elNameEn = document.getElementById('m-name-en');
                        const elNameJp = document.getElementById('m-name-jp');
                        const elDesc = document.getElementById('m-desc');
                        const elId = document.getElementById('m-id');

                        if (elNameEn) elNameEn.innerText = r.nameEn;
                        if (elNameJp) elNameJp.innerText = r.nameJp;
                        if (elDesc) elDesc.innerText = r.desc;
                        if (elId) elId.innerText = r.id;

                        // チャートはアニメーションしないと反映されないので簡易的に幅セット
                        setTimeout(() => {
                            const barR = document.querySelector('.bar-fill.r');
                            const barV = document.querySelector('.bar-fill.v');
                            const barG = document.querySelector('.bar-fill.g');

                            if (barR) barR.style.width = `${r.chart.risk}%`;
                            if (barV) barV.style.width = `${r.chart.variance}%`;
                            if (barG) barG.style.width = `${r.chart.greed}%`;
                        }, 500);
                    }

                    // コラボエリア表示制御
                    const collabSection = document.getElementById('collab-section');
                    if (collabSection) collabSection.style.display = 'block';

                    // UI表示分岐
                    if (window.vipData) { // isVip変数はグローバルだが念のためwindow.vipData確認
                        const vipRes = document.getElementById('vip-mode-result');
                        if (vipRes) vipRes.style.display = 'block';

                        // センターのカレンダーボタンはVIPでは非表示（VIP専用エリア内のボタンを使用）
                        const centralCalBtn = document.getElementById('calendar-btn');
                        if (centralCalBtn) centralCalBtn.style.display = 'none';

                        // ヘッダータイトルの更新 (セレクタ修正)
                        const titleEl = document.querySelector('#result-screen .header');
                        if (titleEl) titleEl.innerHTML = `OFFICIAL TICKET`;

                        // チケットホルダー情報の追加
                        const holderArea = document.getElementById('vip-ticket-holder');
                        const nameEl = document.getElementById('vip-holder-name');
                        if (holderArea && nameEl) {
                            nameEl.innerText = window.vipData.name;
                            holderArea.style.display = 'block';
                        }
                    } else if (window.isWeftMode) {
                        const weftRes = document.getElementById('weft-mode-result');
                        if (weftRes) weftRes.style.display = 'block';

                        const resBtn = document.getElementById('reserve-btn');
                        if (resBtn) resBtn.style.display = 'block';
                        const calBtn = document.getElementById('calendar-btn');
                        if (calBtn) calBtn.style.display = 'block';
                    } else {
                        const warpActions = document.getElementById('warp-mode-actions');
                        if (warpActions) warpActions.style.display = 'block';

                        const resBtn = document.getElementById('reserve-btn');
                        const calBtn = document.getElementById('calendar-btn');
                        const shareDiv = document.querySelector('.share-buttons-container');
                        if (resBtn) resBtn.style.display = 'block';
                        if (calBtn) calBtn.style.display = 'block';
                        if (shareDiv) shareDiv.style.display = 'flex';
                    }

                } catch (e) {
                    console.error('Error during result restoration:', e);
                    // エラー時でも強制的にローディングを消す
                    const loadTxt = document.getElementById('loading-text');
                    if (loadTxt) {
                        loadTxt.innerText = "ERROR LOADING DATA";
                        loadTxt.style.color = "red";
                    }
                } finally {
                    const loadTxt = document.getElementById('loading-text');
                    if (loadTxt && loadTxt.innerText !== "ERROR LOADING DATA") {
                        loadTxt.style.display = 'none';
                    }
                }
            }, 500);
        }
    </script>
</body>

</html>